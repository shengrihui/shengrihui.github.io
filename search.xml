<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode_1221. 分割平衡字符串</title>
    <url>/2021/09/07/Leetcode-1221-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>1221. 分割平衡字符串<br>难度：简单</p>
<p>在一个 <strong>平衡字符串</strong> 中，<code>'L'</code> 和 <code>'R'</code> 字符的数量是相同的。</p>

<p>给你一个平衡字符串&nbsp;<code>s</code>，请你将它分割成尽可能多的平衡字符串。</p>

<p><strong>注意：</strong>分割得到的每个字符串都必须是平衡字符串。</p>

<p>返回可以通过分割得到的平衡字符串的 <strong>最大数量</strong> <strong>。</strong></p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>s = "RLRRLLRLRL"
<strong>输出：</strong>4
<strong>解释：</strong>s 可以分割为 "RL"、"RRLL"、"RL"、"RL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>s = "RLLLLRRRLR"
<strong>输出：</strong>3
<strong>解释：</strong>s 可以分割为 "RL"、"LLLRRR"、"LR" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>s = "LLLLRRRR"
<strong>输出：</strong>1
<strong>解释：</strong>s 只能保持原样 "LLLLRRRR".
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>s = "RLRRRLLRLL"
<strong>输出：</strong>2
<strong>解释：</strong>s 可以分割为 "RL"、"RRRLLRLL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 1000</code></li>
    <li><code>s[i] = 'L' 或 'R'</code></li>
    <li><code>s</code> 是一个 <strong>平衡</strong> 字符串</li>
</ul>


<h3 id="方法一：-贪心"><a href="#方法一：-贪心" class="headerlink" title="方法一： 贪心"></a>方法一： 贪心</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balancedStringSplit</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r, ans = <span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l == r:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">balancedStringSplit</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans, d = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                d += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/split-a-string-<span class="keyword">in</span>-balanced-strings/solution/fen-ge-ping-heng-zi-fu-chuan-by-leetcode-7y8u/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hoq3tI"><img src="https://z3.ax1x.com/2021/09/07/hoq3tI.jpg" alt="平衡字符串提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_1646. 获取生成数组中的最大值</title>
    <url>/2021/08/23/Leetcode-1646-%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>1646. 获取生成数组中的最大值<br>难度：简单</p>
<p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>

<ul>
    <li><code>nums[0] = 0</code></li>
    <li><code>nums[1] = 1</code></li>
    <li>当 <code>2 &lt;= 2 * i &lt;= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>
    <li>当 <code>2 &lt;= 2 * i + 1 &lt;= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>
</ul>

<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>3
<strong>解释：</strong>根据规则：
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
因此，nums = [0,1,1,2,1,3,2,3]，最大值 3
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>1
<strong>解释：</strong>根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>2
<strong>解释：</strong>根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<div class="notranslate"><p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>

<ul>
    <li><code>nums[0] = 0</code></li>
    <li><code>nums[1] = 1</code></li>
    <li>当 <code>2 &lt;= 2 * i &lt;= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>
    <li>当 <code>2 &lt;= 2 * i + 1 &lt;= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>
</ul>

<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>3
<strong>解释：</strong>根据规则：
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
因此，nums = [0,1,1,2,1,3,2,3]，最大值 3
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>1
<strong>解释：</strong>根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>2
<strong>解释：</strong>根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= n &lt;= 100</code></li>
</ul>


<h3 id="方法：-模拟"><a href="#方法：-模拟" class="headerlink" title="方法： 模拟"></a>方法： 模拟</h3><p>代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getMaximumGenerated</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    nums = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    nums[<span class="number">0</span>], nums[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i*<span class="number">2</span>+<span class="number">1</span> &lt;= n:</span><br><span class="line">        nums[i*<span class="number">2</span>] = nums[i]</span><br><span class="line">        nums[i*<span class="number">2</span>+<span class="number">1</span>] = nums[i]+nums[i+<span class="number">1</span>]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br></pre></td></tr></table></figure><br>官方处理奇偶两种情况的方法挺好的。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMaximumGenerated</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nums[i] = nums[i // <span class="number">2</span>] + i % <span class="number">2</span> * nums[i // <span class="number">2</span> + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/get-maximum-in-generated-array/solution/huo-qu-sheng-cheng-shu-zu-zhong-de-zui-d-0z2l/</span></span><br><span class="line"><span class="comment"># 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"># 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/h95spt"><img src="https://z3.ax1x.com/2021/08/23/h95spt.jpg" alt="获取生成数组中的最大值提交记录.jpg"></a></p>
</div>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_1583. 统计不开心的朋友</title>
    <url>/2021/08/20/Leetcode-1583-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>1583. 统计不开心的朋友<br>难度：中等</p>
<p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code> 总是 <strong>偶数</strong> 。</p>

<p>对每位朋友 <code>i</code>，<code>preferences[i]</code> 包含一份 <strong>按亲近程度从高</strong><strong>到低排列</strong> 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code> 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 <code>0</code> 到 <code>n-1</code> 之间的整数表示。</p>

<p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <code>x<sub>i</sub></code> 与 <code>y<sub>i</sub></code> 配对，且 <code>y<sub>i</sub></code> 与 <code>x<sub>i</sub></code> 配对。</p>

<p>但是，这样的配对情况可能会使其中部分朋友感到不开心。在 <code>x</code> 与 <code>y</code> 配对且 <code>u</code> 与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，<code>x</code> 就会不开心：</p>

<ul>
    <li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li>
    <li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li>
</ul>

<p>返回 <strong>不开心的朋友的数目</strong> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]
<strong>输出：</strong>2
<strong>解释：</strong>
朋友 1 不开心，因为：
- <strong>1 与 0 </strong>配对，但 <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高，且
- <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高。
朋友 3 不开心，因为：
- 3 与 2 配对，但 <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高，且
- <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高。
朋友 0 和 2 都是开心的。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 2, preferences = [[1], [0]], pairs = [[1, 0]]
<strong>输出：</strong>0
<strong>解释：</strong>朋友 0 和 1 都开心。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]
<strong>输出：</strong>4
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>2 &lt;= n &lt;= 500</code></li>
    <li><code>n</code> 是偶数</li>
    <li><code>preferences.length&nbsp;== n</code></li>
    <li><code>preferences[i].length&nbsp;== n - 1</code></li>
    <li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li>
    <li><code>preferences[i]</code> 不包含 <code>i</code></li>
    <li><code>preferences[i]</code> 中的所有值都是独一无二的</li>
    <li><code>pairs.length&nbsp;== n/2</code></li>
    <li><code>pairs[i].length&nbsp;== 2</code></li>
    <li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
    <li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n - 1</code></li>

<li>每位朋友都 <strong>恰好</strong> 被包含在一对中</li>
</ul>

<h3 id="方法一：-模拟"><a href="#方法一：-模拟" class="headerlink" title="方法一： 模拟"></a>方法一： 模拟</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题看起来非常非常非常复杂，但其实重点再那两个且的条件：</p>
<blockquote>
<ul>
<li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li>
<li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li>
</ul>

</blockquote>
<p>因此我们的做法就是：</p>
<ol>
<li>找到一个<code>x</code>，以及和他配对的<code>y</code>;</li>
<li>在<code>x</code>的<code>preferences</code>里遍历，在没有遇到<code>y</code>之前，每一个都是可能的<code>u</code>;（这时满足了第一个条件）</li>
<li>在找到与这个<code>u</code>配对的<code>v</code>，然后在<code>u</code>的<code>preferences</code>里找<code>x</code>和<code>v</code>的下标关系是否满足第二个条件，即如果在<code>u</code>的<code>preferences</code>里<code>x</code>的下标小于<code>v</code>的下标，那么，<code>x</code>就是不开心的。<br>为了找所有不开心的<code>x</code>，那么，就是要遍历所有人，同时还要方便找到与它配对的<code>y</code>，所以再开始的时候先创建一个字典，用于记录每个人和谁配对。<br>具体代码实现的时候，还有一个<code>x_isunhappy</code>用于标记<code>x</code>是不是不开心的，如果是，就可以去下一个<code>x</code>了。<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unhappyFriends</span>(<span class="params">n, preferences, pairs</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    unhappy = <span class="number">0</span></span><br><span class="line">    pairs_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">        pairs_dict[x] = y</span><br><span class="line">        pairs_dict[y] = x</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        y = pairs_dict[x]</span><br><span class="line">        x_isunhappy = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> preferences[x]:</span><br><span class="line">            <span class="keyword">if</span> u == y <span class="keyword">or</span> x_isunhappy == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            v = pairs_dict[u]</span><br><span class="line">            <span class="keyword">if</span> preferences[u].index(x) &lt; preferences[u].index(v):</span><br><span class="line">                x_isunhappy = <span class="literal">True</span></span><br><span class="line">                unhappy += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unhappy</span><br></pre></td></tr></table></figure>
官方的方法和我的几乎一样。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -&gt; int:</span><br><span class="line">        order = [[0] * n for _ in range(n)]</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(n - 1):</span><br><span class="line">                order[i][preferences[i][j]] = j</span><br><span class="line">        </span><br><span class="line">        match = [0] * n</span><br><span class="line">        for x, y in pairs:</span><br><span class="line">            match[x] = y</span><br><span class="line">            match[y] = x</span><br><span class="line"></span><br><span class="line">        unhappyCount = 0</span><br><span class="line">        for x in range(n):</span><br><span class="line">            y = match[x]</span><br><span class="line">            index = order[x][y]</span><br><span class="line">            for i in range(index):</span><br><span class="line">                u = preferences[x][i]</span><br><span class="line">                v = match[u]</span><br><span class="line">                if order[u][x] &lt; order[u][v]:</span><br><span class="line">                    unhappyCount += 1</span><br><span class="line">                    break</span><br><span class="line">        </span><br><span class="line">        return unhappyCount</span><br><span class="line"></span><br><span class="line"># 作者：LeetCode-Solution</span><br><span class="line"># 链接：https://leetcode-cn.com/problems/count-unhappy-friends/solution/tong-ji-bu-kai-xin-de-peng-you-by-leetcode-solutio/</span><br><span class="line"># 来源：力扣（LeetCode）</span><br><span class="line"># 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fXcVKK"><img src="https://z3.ax1x.com/2021/08/20/fXcVKK.jpg" alt="提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Leetcode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1719-重构一棵树的方案数</title>
    <url>/2022/02/20/Leetcode-1719-%E9%87%8D%E6%9E%84%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>1719. 重构一棵树的方案数<br>难度：困难</p>
<p>给你一个数组&nbsp;<code>pairs</code> ，其中&nbsp;<code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;，并且满足：</p>

<ul>
    <li><code>pairs</code>&nbsp;中没有重复元素</li>
    <li><code>x<sub>i</sub> &lt; y<sub>i</sub></code></li>
</ul>


<p>令&nbsp;<code>ways</code>&nbsp;为满足下面条件的有根树的方案数：</p>

<ul>
    <li>树所包含的所有节点值都在 <code>pairs</code>&nbsp;中。</li>
    <li>一个数对&nbsp;<code>[x<sub>i</sub>, y<sub>i</sub>]</code> 出现在&nbsp;<code>pairs</code>&nbsp;中&nbsp;<strong>当且仅当</strong><strong>&nbsp;</strong><code>x<sub>i</sub></code>&nbsp;是&nbsp;<code>y<sub>i</sub></code>&nbsp;的祖先或者&nbsp;<code>y<sub>i</sub></code>&nbsp;是&nbsp;<code>x<sub>i</sub></code><sub>&nbsp;</sub>的祖先。</li>
    <li><strong>注意：</strong>构造出来的树不一定是二叉树。</li>
</ul>


<p>两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。</p>

<p>请你返回：</p>

<ul>
    <li>如果&nbsp;<code>ways == 0</code>&nbsp;，返回&nbsp;<code>0</code>&nbsp;。</li>
    <li>如果&nbsp;<code>ways == 1</code>&nbsp;，返回 <code>1</code>&nbsp;。</li>
    <li>如果&nbsp;<code>ways &gt; 1</code>&nbsp;，返回&nbsp;<code>2</code>&nbsp;。</li>
</ul>


<p>一棵 <strong>有根树</strong>&nbsp;指的是只有一个根节点的树，所有边都是从根往外的方向。</p>

<p>我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 <strong>祖先</strong>&nbsp;。根节点没有祖先。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img style="width: 208px; height: 221px;" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/trees2.png"></p>
<pre><b>输入：</b>pairs = [[1,2],[2,3]]
<b>输出：</b>1
<b>解释：</b>如上图所示，有且只有一个符合规定的有根树。
</pre>


<p><strong>示例 2：</strong></p>

<p><img style="width: 234px; height: 241px;" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/tree.png" alt></p>
<pre><b>输入：</b>pairs = [[1,2],[2,3],[1,3]]
<b>输出：</b>2
<b>解释：</b>有多个符合规定的有根树，其中三个如上图所示。
</pre>


<p><strong>示例 3：</strong></p>

<pre><b>输入：</b>pairs = [[1,2],[2,3],[2,4],[1,5]]
<b>输出：</b>0
<b>解释：</b>没有符合规定的有根树。</pre>


<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= pairs.length &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= x<sub>i </sub>&lt; y<sub>i</sub> &lt;= 500</code></li>
    <li><code>pairs</code>&nbsp;中的元素互不相同。</li>
</ul>



<h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h3><p>一开始一直看不懂题目，不明白示例三为什么不行，认为示例三很容易就能画出一棵树来。反复读题之后才意识到题目中“树所包含的所有节点值都在 <code>pairs</code>&nbsp;中。”的意思，就是说构造出来的树的所有信息都要再<code>pairs</code>中体现，也明白了为什么要那样输出，只要找到符合条件的2个就能输出了。<br>于是看示例三就能想到：如果一个节点在一个数对中做了孩子节点，那它在其他数对中只能作为双亲节点，比如示例三中的<code>2</code>节点。<br>不对不对，;<code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&amp;nbsp中，<code>x<sub>i</sub></code>和<code>y<sub>i</sub></code>之间的关系是祖先和后代的关系，而不是双亲孩子的关系，所以这不能用来解题。<br>那也就是说所有祖先后代的关系在<code>pairs</code>当中都有体现，那如果存在根节点的话，每一组数对当中都会有这个根节点咯？——找到根节点了！<br>呀，不是在每个数对中都出现，就是：    </p>
<pre><code>d = defaultdict(set)
for x,y in pairs:
    d[x].add(y)
    d[y].add(x)
</code></pre><p>这样<code>d[根节点]</code>就包含了除自己以外所有的节点，而<code>d[x]</code>就是包含<code>x</code>的所有祖先和后代了。<br>然 后呢？官解是直接模拟，模拟啥呀？<br><code>x<sub>i</sub> &lt; y<sub>i</sub></code>这个条件有什么用吗？应该没有吧，只是一种表示而已吧。<br>能不能再统计一下<code>d[x]</code>的个数，然后用集合的相关运算划分出不同的子树，然后……<br>哎，大约只能想到这了，看官解吧。<br>哎，官解前面设的东西和我的想法好像哦。<br>看了一圈题解，字面上的也基本上都懂了，但离理解还是差点。<br>自己写了一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def checkWays(self, pairs) -&gt; int:</span><br><span class="line">        adj = defaultdict(set)</span><br><span class="line"></span><br><span class="line">        for x, y in pairs:</span><br><span class="line">            adj[x].add(y)</span><br><span class="line">            adj[y].add(x)</span><br><span class="line">        for x in adj:</span><br><span class="line">            adj[x].add(x)</span><br><span class="line">        for i in adj:</span><br><span class="line">            print(i,adj[i])</span><br><span class="line">        adj = sorted(adj.values(), key=lambda item: len(item))</span><br><span class="line">        n = len(adj)</span><br><span class="line">        if len(adj[-1]) &lt; n:</span><br><span class="line">            return 0</span><br><span class="line">        ans = 1</span><br><span class="line">        print(adj)</span><br><span class="line">        for i in range(n - 1):</span><br><span class="line">            for j in range(i + 1, n):</span><br><span class="line">                if adj[i].issubset(adj[j]):</span><br><span class="line">                    if ans != 2 and adj[i] == adj[j]:</span><br><span class="line">                        ans = 2</span><br><span class="line">                    break</span><br><span class="line">            else:</span><br><span class="line">                return 0</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p>将某个节点的所有祖先和所有后代还有它自己装进一个集合里，然后以集合大小为排序依据进行排序。从小的开始，找到包含这个小集合的最小的大集合，那个就是小集合对应的节点的父节点了。然后判断如果这两集合一样大，那就说明可以交换。<br>这样是错误的，问题在于，所有集合都是根节点的那个集合的子集，那所有节点都能认根节点作为它的直接父节点。完了。<br>看官解代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> maxsize</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkWays</span>(<span class="params">self, pairs</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        adj = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">            adj[x].add(y)</span><br><span class="line">            adj[y].add(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检测是否存在根节点</span></span><br><span class="line">        root = <span class="built_in">next</span>((node <span class="keyword">for</span> node, neighbours <span class="keyword">in</span> adj.items() <span class="keyword">if</span> <span class="built_in">len</span>(neighbours) == <span class="built_in">len</span>(adj) - <span class="number">1</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># # 没有根节点</span></span><br><span class="line">        <span class="keyword">if</span> root == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> node, neighbours <span class="keyword">in</span> adj.items():</span><br><span class="line">            <span class="keyword">if</span> node == root:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># # 遍历过程当中当前节点的Degree</span></span><br><span class="line">            currDegree = <span class="built_in">len</span>(neighbours)</span><br><span class="line">            parent = -<span class="number">1</span></span><br><span class="line">            parentDegree = maxsize</span><br><span class="line">            <span class="comment"># 根据 degree 的大小找到 node 的父节点 parent</span></span><br><span class="line">            <span class="comment"># # 遍历 adj[node] ,就是和 node 有关系的所有节点</span></span><br><span class="line">            <span class="keyword">for</span> neighbour <span class="keyword">in</span> neighbours:</span><br><span class="line">                <span class="comment"># # 找到 node 的可能父节点—— parentDegree &gt;= currDegree</span></span><br><span class="line">                <span class="keyword">if</span> currDegree &lt;= <span class="built_in">len</span>(adj[neighbour]) &lt; parentDegree:</span><br><span class="line">                    parent = neighbour</span><br><span class="line">                    parentDegree = <span class="built_in">len</span>(adj[neighbour])</span><br><span class="line">            <span class="comment"># 检测 neighbours 是否为 adj[parent] 的子集</span></span><br><span class="line">            <span class="comment"># # if parent == -1 or not neighbours.issubset(adj[parent]):</span></span><br><span class="line">            <span class="comment"># # ??</span></span><br><span class="line">            <span class="keyword">if</span> parent == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">any</span>(neighbour != parent <span class="keyword">and</span> neighbour <span class="keyword">not</span> <span class="keyword">in</span> adj[parent] <span class="keyword">for</span> neighbour <span class="keyword">in</span> neighbours):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> parentDegree == currDegree:</span><br><span class="line">                ans = <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>其中<code># #</code>是我的注释。<br>现在问题就是，</p>
<pre><code># 检测 neighbours 是否为 adj[parent] 的子集
# # if parent == -1 or not neighbours.issubset(adj[parent]):
if parent == -1 or any(neighbour != parent and neighbour not in adj[parent] for neighbour in neighbours):
return 0
</code></pre><p>我用集合本身的判断是否为另一个集合的子集的函数，结果是错误的。<br>现在就是要重点理解<code>any(neighbour != parent and neighbour not in adj[parent] for neighbour in neighbours)</code>了。还有，<code>parent</code>什么时候会是<code>-1</code>呀？<br>不，在这里<code>parent</code>都不可能是<code>-1</code>，经代码提交确认也是这样。<br>    any(neighbour != parent and neighbour not in adj[parent] for neighbour in neighbours)</p>
<ul>
<li><code>any()</code>只要有一个是True，结果就是True。</li>
<li>遍历当前<code>node</code>的<code>neighbours</code>，若出现一个节点不属于<code>parent</code>那个集合时，就可以证明这个<code>parent</code>不是这个<code>node</code>的父节点：<ul>
<li>当遍历的<code>neighbour</code>不是<code>parent</code>(<code>neighbour != parent</code>为<code>True</code>)时,<code>neighbour</code>又不在<code>parent</code>的集合里，整体值为<code>True</code>，即<code>parent</code>不是当前<code>node</code>的父节点，<code>return 0</code>；</li>
<li>当遍历的<code>neighbour</code>恰好时<code>parent</code>(<code>neighbour != parent</code>为<code>False</code>)时，<code>neighbour</code>也一定不在’parent<code>的集合里，因此整体值为</code>False`;</li>
</ul>
</li>
</ul>
<p>好家伙，总算是理清了。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Leetcode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-2029-石子游戏 IX</title>
    <url>/2022/02/14/Leetcode-2029-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-IX/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>2029.石子游戏 IX 难度：中等</p>
<p>Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code> 是第 <code>i</code> 个石子的价值。</p>

<p>Alice 和 Bob 轮流进行自己的回合，<strong>Alice</strong> 先手。每一回合，玩家需要从 <code>stones</code>&nbsp;中移除任一石子。</p>

<ul>
    <li>如果玩家移除石子后，导致 <strong>所有已移除石子</strong> 的价值&nbsp;<strong>总和</strong> 可以被 3 整除，那么该玩家就 <strong>输掉游戏</strong> 。</li>
    <li>如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。</li>
</ul>


<p>假设两位玩家均采用&nbsp;<strong>最佳</strong> 决策。如果 Alice 获胜，返回 <code>true</code> ；如果 Bob 获胜，返回 <code>false</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>stones = [2,1]
<strong>输出：</strong>true
<strong>解释：</strong>游戏进行如下：
- 回合 1：Alice 可以移除任意一个石子。
- 回合 2：Bob 移除剩下的石子。 
已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。
</pre>


<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>stones = [2]
<strong>输出：</strong>false
<strong>解释：</strong>Alice 会移除唯一一个石子，已移除石子的值总和为 2 。 
由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。
</pre>


<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>stones = [5,1,2,4,3]
<strong>输出：</strong>false
<strong>解释：</strong>Bob 总会获胜。其中一种可能的游戏进行方式如下：
- 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。
- 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。
- 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。
- 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.
- 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.
Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。
</pre>


<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= stones.length &lt;= 10<sup>5</sup></code></li>
    <li><code>1 &lt;= stones[i] &lt;= 10<sup>4</sup></code></li>
</ul>


<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据规则和题目，可以有这些小结论：</p>
<ol>
<li>所谓石子的价值真正有用的是对3取模后的值，我们将移除石子价值总数记为<code>x</code>，每个石子的价值记为<code>s=0,1,2</code>；</li>
<li>Alice想要赢，只有一种情况，就是让Bob移除石子后使得移除石子总数是3的倍数；</li>
<li>为了保证自己不输，自己要移除的石子<code>s</code>不能等于<code>3-x</code>，也就是如果现在<code>x=1</code>，“我”现在能选的石子<code>s</code>只能是1或0；</li>
<li>偶数个<code>s=0</code>相当于没有<code>x=0</code>，因为都是最优走法；</li>
<li>没有<code>s=0</code>，大致情况是：</li>
<li>1,1,2,1,2,1…或2,2,1,2,1,2,1…;</li>
</ol>
<p>讨论<code>s=0</code>偶数个的情况：</p>
<ul>
<li>如果全是<code>s=1</code>,Alice必败；</li>
<li>如果全是<code>s=2</code>,Alice也必败；</li>
<li><p>如果既有<code>s=1</code>，也有<code>s=2</code>， 因为A第一手之后，1和2交替进行，所以，</p>
<ol>
<li>两个数量相等。无论Alice选哪个，Bob最后选的和Alice一开始选的构成三的倍数，所以Alice都赢；</li>
<li><p><code>s=1</code>和<code>s=2</code>不一样多。</p>
<ol>
<li>Alice第一步选少的那个，这样，Bob就会一路选和Alice第一次一样的，直到没了Bob只好选另一个，这时候就构成了三的倍数，Bob输掉，Alice必胜；</li>
<li><p>但如果Alice选较多的那一个（假设是<code>s=2</code>），一顿交替之后，较少的<code>s=1</code>没了，</p>
<ol>
<li><p>如果<code>s=2</code>比<code>s=1</code>只多一个，Alice是最后一个，Alice输掉；</p>
</li>
<li><p>如果<code>s=2</code>比<code>s=1</code>多两个，Bob最后是<code>s=1</code>，根据规则，依然是Bob胜利；</p>
</li>
<li><p>如果<code>s=2</code>比<code>s=1</code>多超过两个，当<code>s=1</code>没了，Bob选<code>s=2</code>，Alice只能再选<code>s=2</code>，构成3的倍数，Alice输掉—就相当于前面全是<code>s=2</code>的情况。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>所以，Alice要选少的那个，一样多就都行。</p>
</li>
<li>综合一下：</li>
<li>如果相同，只有一种，Alice完了；</li>
<li>两种都有，选少的，一样就都可以选；</li>
<li>也就是说，只要<code>s=1</code>或<code>s=2</code>有一个没有，就完了。</li>
</ul>
<p>讨论<code>s=0</code>奇数的情况：</p>
<ul>
<li>Alice第一步肯定不拿<code>s=0</code>;</li>
<li>奇数个<code>s=0</code>有起到转换先手的作用；</li>
<li>那Bob第一步也就是整个的第二回合用不用这个<code>s=0</code>呢？</li>
<li>也先考虑全是<code>s=1</code>或<code>s=2</code>的情况，因为这两其实等价，所以假设全是<code>s=1</code>：<ol>
<li>如果数量只有1个或2个，那Alice必输<br>她都没机会让Bob取了之后构成3的倍数啊。</li>
<li>如果数量大于2个<ol>
<li>Bob首先就选了<code>s=0</code>，那现在的Alice就相当于之前讨论的<code>s=0</code>个数是偶数且全是<code>s=1</code>这种情况下的Bob，Alice赢；</li>
<li>Bob先不选<code>s=0</code>，那Alice不选<code>s=0</code>就输了，所以肯定会选<code>s=0</code>。。。Bob输了。</li>
</ol>
</li>
</ol>
</li>
<li>所以，如果这数量超过2，Alice必胜，不然就必败</li>
<li>现在考虑既有<code>s=1</code>也有<code>s=2</code>：</li>
<li>非常多的<code>s=2</code>或<code>s=1</code>意义不大，就用三个以内的数量来代表；</li>
<li><code>s=1</code>和<code>s=1</code>各一个（代表一样多）：Alice必输啊；</li>
<li><code>s=1</code>1个，<code>s=2</code>2个（代表两个数量相差1）：<ol>
<li>Alice选<code>s=1</code>，Bob选<code>s=0</code>，Alice最后回选到<code>s=2</code>而输掉，Bob为了赢那肯定会选<code>s=0</code>：</li>
<li>Alice选<code>s=2</code>，<ol>
<li>Bob不选<code>s=0</code>,而是选了和Alice一样的<code>s=2</code>，那Alice接下来选<code>s=1</code>输，选<code>s=0</code>，也是输；</li>
<li>Bob选<code>s=0</code>,那Alice接下来只能接着选<code>s=2</code>，最终还是输。</li>
</ol>
</li>
</ol>
</li>
<li>所以这种情况Alice必输。</li>
<li>换个角度理解这种Alice必输的情况，因为总的数量是个偶数（1个<code>s=1</code>，2个<code>s=2</code>，奇数个<code>s=0</code>），而Alice要赢就要让Bob自己构成3的倍数，他俩又都是高手，能撑到最后，而最后走完，总和不可能是3的倍数，所以Alice必输。</li>
<li>其实不用接着讨论数量差更大的情况了，对之前讨论的只有一种的情况，往里加一对<code>s=1</code>和<code>s=2</code>就好了，效果是一样的。</li>
<li>所以综合一下：</li>
<li>其中一个没有，得相差超过2，能赢；</li>
<li>两个都有，相差两个之内，Alice输；</li>
<li>所以，只要两个数量相差超过2Alice就能赢。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def stoneGameIX(self, stones) -&gt; bool:</span><br><span class="line">        a = [0, 0, 0]</span><br><span class="line">        for i in stones:</span><br><span class="line">            a[i % 3] += 1</span><br><span class="line">        if a[0] % 2 == 0:</span><br><span class="line">            # if a[1]*a[2]==0:</span><br><span class="line">            #     return False</span><br><span class="line">            return a[1] * a[2] != 0</span><br><span class="line">        else:</span><br><span class="line">            return abs(a[1] - a[2]) &gt; 2</span><br></pre></td></tr></table></figure>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/7hd2IU"><img src="https://s4.ax1x.com/2022/01/22/7hd2IU.png" alt="本题提交记录"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_233. 数字 1 的个数</title>
    <url>/2021/08/23/Leetcode-233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode_345. 反转字符串中的元音字母</title>
    <url>/2021/08/19/Leetcode-345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>345. 反转字符串中的元音字母<br>难度：简单<br>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p>示例 1：</p>
<p>输入：”hello”<br>输出：”holle”<br>示例 2：</p>
<p>输入：”leetcode”<br>输出：”leotcede”</p>
<p>提示：</p>
<p>元音字母不包含字母 “y” 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">https://leetcode-cn.com/problems/reverse-vowels-of-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p>这提不难。<br>弄两个指针<code>i</code>和<code>j</code>，<code>i</code>从前往后走，<code>j</code>从后往前走，当遇到原因字母的时候，就停下来。当两个指针都停下来的时候，交换两个字母。使用<code>while</code>循环，退出条件是<code>i</code>和<code>j</code>重合。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>python<pre><code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def reverseVowels(s):</span><br><span class="line">l = list(s)</span><br><span class="line">i, j = 0, len(s)-1</span><br><span class="line">Vowels = [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;A&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;U&#x27;]</span><br><span class="line"># vowels = &quot;aeiouAEIOU&quot;</span><br><span class="line">i_step = 1</span><br><span class="line">j_step = -1</span><br><span class="line">while i &lt; j:</span><br><span class="line">    if l[i] in Vowels:</span><br><span class="line">        i_step = 0</span><br><span class="line">    if l[j] in Vowels:</span><br><span class="line">        j_step = 0</span><br><span class="line"></span><br><span class="line">    if i_step == j_step == 0:</span><br><span class="line">        l[i], l[j] = l[j], l[i]</span><br><span class="line">        i_step = 1</span><br><span class="line">        j_step = -1</span><br><span class="line">    i += i_step</span><br><span class="line">    j += j_step</span><br><span class="line">return &#x27;&#x27;.join(l)</span><br></pre></td></tr></table></figure>
</code></pre>  和官方题解几乎一样。</li>
<li>C<pre><code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   	<span class="type">int</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">   &#123;</span><br><span class="line">	<span class="type">char</span> vowels[] = <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; vowels[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == vowels[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">reverseVowels</span><span class="params">(<span class="type">char</span>* s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> i_step = <span class="number">1</span>, j_step = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> == isVowel(s[i]))</span><br><span class="line">			i_step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> == isVowel(s[j]))</span><br><span class="line">			j_step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i_step == <span class="number">0</span> &amp;&amp; j_step == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c %c %s\n&quot;</span>, s[i], s[j], s);</span><br><span class="line">			tmp = s[i];</span><br><span class="line">			s[i] = s[j];</span><br><span class="line">			s[j] = tmp;</span><br><span class="line">			i_step = <span class="number">1</span>;</span><br><span class="line">			j_step = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i += i_step;</span><br><span class="line">		j += j_step;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fHEmKP"><img src="https://z3.ax1x.com/2021/08/19/fHEmKP.jpg" alt="python提交记录"></a><br><a href="https://imgtu.com/i/fHEZvt"><img src="https://z3.ax1x.com/2021/08/19/fHEZvt.jpg" alt="C语言提交记录"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_502. IPO</title>
    <url>/2021/09/08/Leetcode-502-IPO/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode_443. 压缩字符串</title>
    <url>/2021/08/22/Leetcode-443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>443. 压缩字符串<br>难度：中等</p>
<p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p>

<p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p>

<ul>
    <li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li>
    <li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li>
</ul>

<p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p>

<p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p>

<p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>chars = ["a","a","b","b","c","c","c"]
<strong>输出：</strong>返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
<strong>解释：</strong>
"aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>chars = ["a"]
<strong>输出：</strong>返回 1 ，输入数组的前 1 个字符应该是：["a"]
<strong>解释：</strong>
没有任何字符串被替代。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
<strong>输出：</strong>返回 4 ，输入数组的前 4 个字符应该是：["a","b","1","2"]。
<strong>解释：</strong>
由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。
注意每个数字在数组中都有它自己的位置。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= chars.length &lt;= 2000</code></li>
    <li><code>chars[i]</code> 可以是小写英文字母、大写英文字母、数字或符号</li>
</ul>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>要注意理解题目中确实是要将<code>chars</code>里的内容给改掉的。<br>我的第一个方法是另外创建一个<code>s</code>，初始就为<code>chars[0]</code>，然后遍历<code>chars</code>，用一个变量<code>c</code>来记相同的个数，直到遇到的字符与<code>s[-1]</code>不一样或者到了最后一个，就将计数器<code>s</code>强制转换乘字符串并一个一个加到<code>s</code>里去。最后再将<code>chars</code>里的字符一个个改掉。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compress</span>(<span class="params">chars</span>):</span><br><span class="line">    s = [chars[<span class="number">0</span>]]</span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    n = <span class="built_in">len</span>(chars)</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">if</span> s[-<span class="number">1</span>] != chars[i]:</span><br><span class="line">            <span class="keyword">if</span> c != <span class="number">1</span>:</span><br><span class="line">                s.extend(<span class="built_in">list</span>(<span class="built_in">str</span>(c)))</span><br><span class="line">            s.append(chars[i])</span><br><span class="line">            c = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == n-<span class="number">1</span>:</span><br><span class="line">                s.extend(<span class="built_in">list</span>(<span class="built_in">str</span>(c)))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        chars[i] = x</span><br><span class="line">    <span class="comment"># print(chars)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p>不创建新的列表或字符串，在原有的列表上直接修改。<br>（其实是三指针）设一个写指针，两个读指针。大思路并不难，主要是具体实现上需要有些注意。比如，<code>if right == n-1 or chars[right] != chars[right+1]:</code>这句，①将是不是到了最后一个位置的判断放在<code>or</code>前面，②判断两个字符是否相等，是判断指针和它的下一个是不是一样，而不是往前判断，这样就可以解决好多最后一个字符的情况（往后判断的话，需要考虑最后一个是否与前一个相等的情况，会麻烦一些）。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compress</span>(<span class="params">chars</span>):</span><br><span class="line">    write = left = <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(chars)</span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> right == n-<span class="number">1</span> <span class="keyword">or</span> chars[right] != chars[right+<span class="number">1</span>]:</span><br><span class="line">            l = right-left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(l):</span><br><span class="line">                    write += <span class="number">1</span></span><br><span class="line">                    chars[write] = i</span><br><span class="line">            left = right+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right != n-<span class="number">1</span>:</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">                chars[write] = chars[right+<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(chars[:write+1])</span></span><br><span class="line">    <span class="keyword">return</span> write+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hSKTDP"><img src="https://z3.ax1x.com/2021/08/22/hSKTDP.jpg" alt="压缩字符串提交记录jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_526. 优美的排列</title>
    <url>/2021/08/18/Leetcode-526-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>526. 优美的排列<br>难度：中等<br>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p>
<p>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？</p>
<p>示例1:</p>
<p>输入: 2<br>输出: 2<br>解释: </p>
<p>第 1 个优美的排列是 [1, 2]:<br>  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</p>
<p>第 2 个优美的排列是 [2, 1]:<br>  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除<br>说明:</p>
<p>N 是一个正整数，并且不会超过15。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/beautiful-arrangement">https://leetcode-cn.com/problems/beautiful-arrangement</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法零：流氓方法"><a href="#方法零：流氓方法" class="headerlink" title="方法零：流氓方法"></a>方法零：流氓方法</h3><p>因为题目说明了N不会超过15，那就用例测试所有的数得到答案，然后用列表或者一串<code>if</code>语句就可以通过了。</p>
<h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>本来就隐约觉得会用到回溯算法，但还是想先用排列组合的方法试一下，但太太困难了，最后还是用了回溯算法。<br>先创建一个字典<code>d</code>，可以理解成键是第几个位置，对应的值是该位置上能放哪些数。<br>接下来是回溯函数，设置两个参数，第一个是用于记录当前状态的列表，第二个是 现在要填的是哪一个位置<code>pos</code>，返回当前状态下的优美排列数<code>c</code>。<br><code>c</code>初始设为0，<code>i</code>遍历可以在<code>pos</code>位置上的所有数，即<code>d[pos]</code>，如果<code>i</code>不在列表之内，就将它填到列表的对应位置上，并<code>c += func(s, pos+1)</code>，递归到下一个<code>pos</code>中，直到<code>pos==n</code>时，<code>c += 1</code>。<br>可能还是直接看代码清楚一些吧。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def countArrangement(n):</span><br><span class="line">    d = defaultdict(list)</span><br><span class="line">    # 第num个位置上可以放哪些数</span><br><span class="line">    for num in range(1, n+1):</span><br><span class="line">        for i in range(1, num+1):</span><br><span class="line">            if num % i == 0:</span><br><span class="line">                d[num].append(i)</span><br><span class="line">                if num != i:</span><br><span class="line">                    d[i].append(num)</span><br><span class="line"></span><br><span class="line">    def func(s, pos):</span><br><span class="line">        c = 0</span><br><span class="line">        for i in d[pos]:</span><br><span class="line">            if i not in s:</span><br><span class="line">                s[pos-1] = i</span><br><span class="line">                if pos == n:</span><br><span class="line">                    c += 1</span><br><span class="line">                else:</span><br><span class="line">                    c += func(s, pos+1)</span><br><span class="line">                s[pos-1] = 0</span><br><span class="line">        return c</span><br><span class="line">    return func([0]*n, 1)</span><br></pre></td></tr></table></figure>
<p>官方的回溯算法和我写得几乎一样，只是他用的是集合。我一开始也是想用集合的，但不知道集合的<code>disturb</code>方法，才改成了列表。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countArrangement(self, n: int) -&gt; int:</span><br><span class="line">        match = defaultdict(list)</span><br><span class="line">        for i in range(1, n + 1):</span><br><span class="line">            for j in range(1, n + 1):</span><br><span class="line">                if i % j == 0 or j % i == 0:</span><br><span class="line">                    match[i].append(j)</span><br><span class="line">        </span><br><span class="line">        num = 0</span><br><span class="line">        vis = set()</span><br><span class="line"></span><br><span class="line">        def backtrack(index: int) -&gt; None:</span><br><span class="line">            if index == n + 1:</span><br><span class="line">                nonlocal num</span><br><span class="line">                num += 1</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            for x in match[index]:</span><br><span class="line">                if x not in vis:</span><br><span class="line">                    vis.add(x)</span><br><span class="line">                    backtrack(index + 1)</span><br><span class="line">                    vis.discard(x)</span><br><span class="line">                   </span><br><span class="line">        backtrack(1)</span><br><span class="line">        return num</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/beautiful-arrangement/solution/you-mei-de-pai-lie-by-leetcode-solution-vea2/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二：状态压缩-动态规划"><a href="#方法二：状态压缩-动态规划" class="headerlink" title="方法二：状态压缩+动态规划"></a>方法二：状态压缩+动态规划</h3><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>这个方法实在难理解，借助官方题解下的评论才勉强看懂。也不知道什么叫状态压缩。<br>首先，是动态规划的状态表示。这里用二进制数表示，从右往左数，第<code>i</code>位上的数字是1，就表示<code>i</code>这个数字被选取了。创建长度为<code>1&lt;&lt;n</code>的数组<code>f</code>，表示某一状态下的优美排列数。<br>以<code>n=6</code>举例。<code>f[000110]</code>的意思是（这里下标里的数都是二进制数）：数字2和3能够组成的优美排列数。<br>所以，最后返回的结果就是<code>f[1&lt;&lt;n -1]</code>，即<code>f[111111]</code>。<br>然后是转移方程。<code>f[111111] = f[011111] + f[101111] + f[110111] + f[111011] + f[111101] + f[111110]</code>，也就是说，要算取了6个数的优美排列，就算上所有任意去掉这已经取了的6个数中的一个的状态的优美排列数。当然，事实上并不是所有的数都要相加，因为还需要判断，去掉的那个数能否放在第6个位置上。比如<code>f[101111]</code>这时数字<code>5</code>还没有取，而<code>5</code>并不能放在第6个位置上。<br>再举个例子。<code>f[100110]</code>是要算数字<code>2</code>、<code>3</code>和<code>6</code>这3个数的优美排列，那就看哪个数可以放在第3个位置上，这里<code>6</code>和<code>3</code>可以放在第3个位置上，而这时候已经取了的数字分别是<code>2</code>、<code>3</code>和<code>2</code>、<code>6</code>所以<code>f[100110] = f[000110] + f[100010]</code>。<br>因此，设计双重循环，外层<code>mask</code>循环遍历所有状态，内存<code>i</code>循环做的事情是从0（最右边）开始遍历<code>mask</code>的每一位，如果第<code>i+1</code>位上是<code>1</code>，并且这个<code>1</code>对应的数<code>i+1</code>能放在这个位置上（这句话的意思是：假装还没有取<code>i+1</code>这个数，此时已经取了<code>num - 1</code>个数，那 <code>i+1</code>能否放在<code>num</code>这个位置上，所以，<code>num</code>的意思就是要求的<code>mask</code>当中已经取了的数的数量，所以，<code>num</code>可以通过统计<code>mask</code>中有几个<code>1</code>来获得），那么<code>f[mask]</code>就可以加上这种状态下的优美排列数了。<br>还是结合代码进行理解吧。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def countArrangement(n):</span><br><span class="line">    # f[X] X是一个二进制数，</span><br><span class="line">    # 例：f[000110]，表示数字2和3被选取后排在前面的优美排列数</span><br><span class="line">    # 从右往左数，1表示被选</span><br><span class="line">    f = [0]*(1 &lt;&lt; n)</span><br><span class="line">    f[0] = 1</span><br><span class="line"></span><br><span class="line">    # 动态规划，mask 遍历1到 1&lt;&lt;n</span><br><span class="line">    for mask in range(1, 1 &lt;&lt; n):</span><br><span class="line">        # 计mask有多少个1</span><br><span class="line">        # 以100110举例例，mum=3</span><br><span class="line">        # 也就是说，2、3、6被选取了，要放在前三个求他们呢的优美排列数</span><br><span class="line">        # 那需要判断第3个位置（也就是第 num个位置）可以放谁，</span><br><span class="line">        # 这里可以放3和6，</span><br><span class="line">        # 前两个位置是2，6，f[100110] += f[100010]</span><br><span class="line">        # 前两个位置是2，3，f[100110] += f[000110]</span><br><span class="line">        num = bin(mask).count(&quot;1&quot;)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            # mask &amp; (1 &lt;&lt; i  mask的第i+1位是不是1</span><br><span class="line">            # 如果是，</span><br><span class="line">            # i+1这个数能不能放在 num 这个位置上</span><br><span class="line">            # 如果可以，</span><br><span class="line">            # mask ^ (1 &lt;&lt; i) mask的第i+1位改为0</span><br><span class="line">            # f[mask] += f[mask ^ (1 &lt;&lt; i)]</span><br><span class="line">            # 注意i与i+1，i-1的区别含义</span><br><span class="line">            if (mask &amp; (1 &lt;&lt; i) and (num % (i+1) == 0 or (i+1) % num == 0)):</span><br><span class="line">                f[mask] += f[mask ^ (1 &lt;&lt; i)]</span><br><span class="line">        # for i in range(1,n+1):</span><br><span class="line">        #     if (mask &amp; (1 &lt;&lt; (i-1)) and (num % i == 0 or i % num == 0)):</span><br><span class="line">        #         f[mask] += f[mask ^ (1 &lt;&lt; (i-1))]</span><br><span class="line">    return f[(1 &lt;&lt; n)-1]</span><br></pre></td></tr></table></figure>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><img src="https://z3.ax1x.com/2021/08/18/fI1buR.jpg" alt="526. 优美的排列提交记录"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_541. 反转字符串 II</title>
    <url>/2021/08/20/Leetcode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>541. 反转字符串 II<br>难度：简单</p>
<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每 <code>2k</code> 个字符反转前 <code>k</code> 个字符。</p>

<ul>
    <li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
    <li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>s = "abcdefg", k = 2
<strong>输出：</strong>"bacdfeg"
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>s = "abcd", k = 2
<strong>输出：</strong>"bacd"
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
    <li><code>s</code> 仅由小写英文组成</li>
    <li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
</ul>


<h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>难度不大，直接上代码、<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        t = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(t), <span class="number">2</span> * k):</span><br><span class="line">            t[i: i + k] = <span class="built_in">reversed</span>(t[i: i + k])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def reverseStr(self, s: str, k: int) -&gt; str:</span></span><br><span class="line"><span class="comment">#         kk = 2*k</span></span><br><span class="line"><span class="comment">#         n = len(s)</span></span><br><span class="line"><span class="comment">#         i, j = 0, k-1</span></span><br><span class="line"><span class="comment">#         st = list(s)</span></span><br><span class="line"><span class="comment">#         while i &lt; n:</span></span><br><span class="line"><span class="comment">#             start, end = i, j</span></span><br><span class="line"><span class="comment">#             if j &gt;= n:</span></span><br><span class="line"><span class="comment">#                 end = n-1</span></span><br><span class="line"><span class="comment">#             # print(i, j, start, end, n)</span></span><br><span class="line"><span class="comment">#             while start &lt; end:</span></span><br><span class="line"><span class="comment">#                 st[start], st[end] = st[end], st[start]</span></span><br><span class="line"><span class="comment">#                 start += 1</span></span><br><span class="line"><span class="comment">#                 end -= 1</span></span><br><span class="line"><span class="comment">#             i += kk</span></span><br><span class="line"><span class="comment">#             j += kk</span></span><br><span class="line"><span class="comment">#         return &#x27;&#x27;.join(st)</span></span><br></pre></td></tr></table></figure><br>注释掉的是我的，没注释掉的是官方的。可见对python的有些东西还是不熟悉。</p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fOVZSe"><img src="https://z3.ax1x.com/2021/08/20/fOVZSe.jpg" alt="通过.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_551. 学生出勤记录 I</title>
    <url>/2021/08/17/Leetcode-551-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-I/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>551.-学生出勤记录-I<br>难度：简单<br>给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<p>‘A’：Absent，缺勤<br>‘L’：Late，迟到<br>‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：</p>
<p>按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>学生 不会 存在 连续 3 天或 3 天以上的迟到（’L’）记录。<br>如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。</p>
<p>示例 1：</p>
<p>输入：s = “PPALLP”<br>输出：true<br>解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。<br>示例 2：</p>
<p>输入：s = “PPALLL”<br>输出：false<br>解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000<br>s[i] 为 ‘A’、’L’ 或 ‘P’</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/student-attendance-record-i">https://leetcode-cn.com/problems/student-attendance-record-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>太简单了，略</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>python<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def checkRecord(self, s: str) -&gt; bool:</span><br><span class="line">        return s.count(&quot;A&quot;)&lt;2 and s.count(&quot;LLL&quot;)&lt;=0</span><br></pre></td></tr></table></figure></li>
<li>C<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">checkRecord</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">	<span class="type">int</span> absent = <span class="number">0</span>, late = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*s == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			absent++;</span><br><span class="line">			late = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (absent == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*s == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			late++;</span><br><span class="line">			<span class="keyword">if</span> (late == <span class="number">3</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			late = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/f4KPi9"><img src="https://z3.ax1x.com/2021/08/17/f4KPi9.png" alt="551. 学生出勤记录 I.png"></a><br><a href="https://imgtu.com/i/f4h6TP"><img src="https://z3.ax1x.com/2021/08/17/f4h6TP.jpg" alt="551. 学生出勤记录 IC语言"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_552. 学生出勤记录 II</title>
    <url>/2021/08/19/Leetcode-552-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-II/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>552. 学生出勤记录 II<br>难度：困难<br>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<ul>
    <li><code>'A'</code>：Absent，缺勤</li>
    <li><code>'L'</code>：Late，迟到</li>
    <li><code>'P'</code>：Present，到场</li>
</ul>

<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>

<ul>
    <li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>
    <li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>
</ul>

<p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>8
<strong>解释：
</strong>有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>3
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 10101
<strong>输出：</strong>183236316
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>



<h3 id="方法一和方法二：我的动态规划-排列组合（-泰波纳契数列）"><a href="#方法一和方法二：我的动态规划-排列组合（-泰波纳契数列）" class="headerlink" title="方法一和方法二：我的动态规划+排列组合（+泰波纳契数列）"></a>方法一和方法二：我的动态规划+排列组合（+泰波纳契数列）</h3><p>因为A的情况只有两种：一种是没有A，一种是有A，所以分开考虑。而有A的情况下，A只能有一个，所以考虑将这一个A分别放在字符串的所有位置，这样就将整个字符串分成了左右两个没有A的小部分。若用<code>dp[i]</code>记只有p和L组成的长度为<code>i</code>的字符串当中数量，那么带上A的总数就是将A放在每个位置上的时候<code>dp[A左边长度]*dp[A右边的长度]</code>的总和。而最前面考虑的整个字符串当中没有A的情况即为<code>dp[总长度]</code>。<br>所以接下来就是<code>dp[i]</code>的状态转移方程了。这里再建立两个状态，<code>present[i]</code>和<code>late[i]</code>，分别用于表示长度为<code>i</code>时候以P和L开头（或结尾，其实一样的）的符合条件的数量。于是有状态转移方程：</p>
<ul>
<li><code>present[i] = present[i-1]+late[i-1]</code><br> 因为P可以既可以接在P后边，也可以接在L后边。 </li>
<li><code>late[i] = present[i-1]+present[i-2]</code><br> 因为L可以接在两种情况后边：①恨着P；②只有一个L，这种时候就需要隔着一位是P了。</li>
<li><code>dp[i] = present[i]+late[i]</code><br>这样就可以写代码了。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    dp, late, present = [<span class="number">0</span>]*(n+<span class="number">1</span>), [<span class="number">0</span>]*(n+<span class="number">1</span>), [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># dp, late, present = &#123;&#125;, &#123;&#125;, &#123;&#125;</span></span><br><span class="line">    present[<span class="number">0</span>] = late[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    present[<span class="number">1</span>] = late[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    present[<span class="number">2</span>] = late[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        present[i] = present[i-<span class="number">1</span>]+late[i-<span class="number">1</span>]</span><br><span class="line">        late[i] = present[i-<span class="number">1</span>]+present[i-<span class="number">2</span>]</span><br><span class="line">        dp[i] = (present[i]+late[i]) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">    <span class="comment"># print(present)</span></span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        t = dp[i]*dp[n-<span class="number">1</span>-i]</span><br><span class="line">        ret += t % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">    ret += dp[n]</span><br><span class="line">    <span class="keyword">return</span> ret % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
初始状态可以人工算出。<br>我以为我的思路那么简单清晰易懂，肯定没有问题（虽然确实可以解），但是提交之后超出时间限制了！以为因为中间没有每一步都取模（刚开始的时候没有）会导致大数运算变慢，于是每一步都加上取模运算；以为因为是列表取值慢于是有改成字典；以为网断了（其实并没有），重新连了网——而这些都没有用！<br>后来觉得可能是循环里头<code>[]</code>的取值操作有点多，于是将状态转移方程展开往下写，发现这里竟然有个泰波纳契数列。<br>dp[i]<br>= present[i]+late[i]<br>=present[i-1]+late[i-1]+present[i-1]+present[i-2]<br>=present[i-1]+(present[i-2]+present[i-3]) + present[i-1]+present[i-2]<br>=2<em>present[i-1]+2</em>present[i-2]+present[i-3]<br>于是“改进”了方法的前面部分。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkRecord2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">19</span></span><br><span class="line">    <span class="comment"># dp = [0]*(n+1)</span></span><br><span class="line">    dp = &#123;&#125;</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>], dp[<span class="number">3</span>] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, n+<span class="number">1</span>):</span><br><span class="line">        dp[i] = a+<span class="number">2</span>*b+<span class="number">2</span>*c</span><br><span class="line">        a, b, c = b, c, a+b+c</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
然而仍然超时。——事实上这种更用时，后面放性能分析。<br><a href="https://imgtu.com/i/fq7VpQ"><img src="https://z3.ax1x.com/2021/08/19/fq7VpQ.jpg" alt="超出时间限制.jpg"></a></li>
</ul>
<h3 id="方法三和方法四：官方的动态规划和我照官方的动态规划"><a href="#方法三和方法四：官方的动态规划和我照官方的动态规划" class="headerlink" title="方法三和方法四：官方的动态规划和我照官方的动态规划"></a>方法三和方法四：官方的动态规划和我照官方的动态规划</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkRecord</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># 长度，A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp = [[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - <span class="number">1</span>][j][k]) % MOD</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][k]) % MOD</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>]) % MOD</span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                total += dp[n][j][k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total % MOD</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/student-attendance-record-ii/solution/xue-sheng-chu-qin-ji-lu-ii-by-leetcode-s-kdlm/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>借助他前面的讲解，也并没有很看懂，但了解了大概意思，然后理解着自己写了一个。<br>代码前面部分意思是列举所有情况，开头数字是dp下标。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkRecord5</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="comment"># 0 前面没有A，现在要加P  +=[0]+[1]+[2]</span></span><br><span class="line">    <span class="comment"># 1 前面没有A，上一个不是L，现在要加L  +=[0]</span></span><br><span class="line">    <span class="comment"># 2 前面没有A，上一个是L，现在要加L    +=[1]</span></span><br><span class="line">    <span class="comment"># 3 前面有A，现在要加P   +=[6]+[3]+[4]+[5]</span></span><br><span class="line">    <span class="comment"># 4 前面有A，上一个不是L，现在要加L    +=[6]+[3]</span></span><br><span class="line">    <span class="comment"># 5 前面有A，上一个是L，现在要加L     +=[4]</span></span><br><span class="line">    <span class="comment"># 6 现在要加A  +=[0]+[1]+[2]</span></span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">    <span class="comment"># dp = [[0 for _ in range(7)] for _ in range(n+1)]</span></span><br><span class="line">    <span class="comment"># dp[1] = [1, 1, 0, 0, 0, 0, 1]</span></span><br><span class="line">    <span class="comment"># for i in range(2, n+1):</span></span><br><span class="line">    <span class="comment">#     dp[i][0] += (dp[i-1][0]+dp[i-1][1]+dp[i-1][2])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][1] += dp[i-1][0]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][2] += dp[i-1][1]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][3] += (dp[i-1][6]+dp[i-1][3]+dp[i-1][4]+dp[i-1][5])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][4] += (dp[i-1][6]+dp[i-1][3])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][5] += dp[i-1][4]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][6] += (dp[i-1][0]+dp[i-1][1]+dp[i-1][2])% MOD</span></span><br><span class="line">    <span class="comment"># return sum(dp[n])%MOD</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)], [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)]]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        a, b = i % <span class="number">2</span>, <span class="number">1</span>-i % <span class="number">2</span></span><br><span class="line">        dp[a][<span class="number">0</span>] += (dp[b][<span class="number">0</span>]+dp[b][<span class="number">1</span>]+dp[b][<span class="number">2</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">1</span>] += dp[b][<span class="number">0</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">2</span>] += dp[b][<span class="number">1</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">3</span>] += (dp[b][<span class="number">6</span>]+dp[b][<span class="number">3</span>]+dp[b][<span class="number">4</span>]+dp[b][<span class="number">5</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">4</span>] += (dp[b][<span class="number">6</span>]+dp[b][<span class="number">3</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">5</span>] += dp[b][<span class="number">4</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">6</span>] += (dp[b][<span class="number">0</span>]+dp[b][<span class="number">1</span>]+dp[b][<span class="number">2</span>]) % MOD</span><br><span class="line">        dp[b] = [<span class="number">0</span>]*<span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp[n % <span class="number">2</span>]) % MOD</span><br></pre></td></tr></table></figure><br>这里其实也有两个方法，没注释掉的用上了滚动数组，这里需要注意的是清零的这一步<code>dp[b] = [0]*7</code>操作不能忘了。</p>
<h3 id="方法五：-矩阵快速幂"><a href="#方法五：-矩阵快速幂" class="headerlink" title="方法五： 矩阵快速幂"></a>方法五： 矩阵快速幂</h3><p>有我前面列举过所有情况的基础上，写出矩阵快速幂就并不是那么难了。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkRecord6</span>(<span class="params">n</span>):</span><br><span class="line">    mat = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    ]</span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="comment"># a[r*m] * b[m*c] = ret[r*c]</span></span><br><span class="line">        r, m, c = <span class="built_in">len</span>(a), <span class="built_in">len</span>(a[<span class="number">0</span>]), <span class="built_in">len</span>(b[<span class="number">0</span>])</span><br><span class="line">        ret = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(c)]<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(r)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    ret[i][j] += a[i][k]*b[k][j]</span><br><span class="line">                    ret[i][j] %= MOD</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixpow</span>(<span class="params">mat, n</span>):</span><br><span class="line">        ret = [[<span class="number">1</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ret = multiply(mat, ret)</span><br><span class="line">            mat = multiply(mat, mat)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    ret = matrixpow(mat, n)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">        ans += i[<span class="number">0</span>] % MOD</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br></pre></td></tr></table></figure></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><h5 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h5><ul>
<li>动态规划通过<br> <a href="https://imgtu.com/i/fqXhEn"><img src="https://z3.ax1x.com/2021/08/19/fqXhEn.jpg" alt="动态规划通过.jpg"></a></li>
<li>矩阵快速幂（官方）<br> <a href="https://imgtu.com/i/fqXjER"><img src="https://z3.ax1x.com/2021/08/19/fqXjER.jpg" alt="矩阵快速幂（官方）.jpg"></a></li>
<li>矩阵快速幂（自己）<br> <a href="https://imgtu.com/i/fqjVUI"><img src="https://z3.ax1x.com/2021/08/19/fqjVUI.jpg" alt="矩阵快速幂（自己）.jpg"></a></li>
</ul>
</li>
<li><h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5> 用<code>test = [3, 4, 5, 6, 7, 10101, 100000]</code>分别作为输入，用spyder进行性能分析。<br> <a href="https://imgtu.com/i/fqjXQS"><img src="https://z3.ax1x.com/2021/08/19/fqjXQS.jpg" alt="性能分析.jpg"></a><br> 1、2、3、5分别对应前面的方法一、二、三、四。可见泰波纳契数列的”改进“是个灾难啊。6、7分别对应自己和官方的矩阵快速幂。</li>
<li><h5 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h5> 1.真难！不是题目本身，因为虽然是一道困难提，但我还是比较快地有了方法 ，并且能够正确求解，但是总是超时而不清楚原因再哪实在崩溃！<br> 2.<code>1 &lt;= n &lt;= 10<sup>5</sup></code>，10<sup>5</sup>大约是273多年。</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode困难</tag>
        <tag>动态规划</tag>
        <tag>快速幂/矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_57|. 出界的路径数</title>
    <url>/2021/08/20/Leetcode-576-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol>
<li>出界的路径数<br>难度：简单<p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>

</li>
</ol>
<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img style="width: 500px; height: 296px;" src="https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png" alt>
<pre><strong>输入：</strong>m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
<strong>输出：</strong>6
</pre>

<p><strong>示例 2：</strong></p>
<img style="width: 500px; height: 293px;" src="https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png" alt>
<pre><strong>输入：</strong>m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1
<strong>输出：</strong>12
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= m, n &lt;= 50</code></li>
    <li><code>0 &lt;= maxMove &lt;= 50</code></li>
    <li><code>0 &lt;= startRow &lt; m</code></li>
    <li><code>0 &lt;= startColumn &lt; n</code></li>
</ul>

<h3 id="f方法一：-动态规划"><a href="#f方法一：-动态规划" class="headerlink" title="f方法一： 动态规划"></a>f方法一： 动态规划</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这一题显然是要用动态规划来做。状态也不难写，<code>dp[move][r][c]</code>表示第<code>move</code>步走到第<code>r</code>行第<code>c</code>列的数量。状态转移方程也不难想到，即<code>dp[move][r][c]</code>等于<code>move-1</code>上一步步第<code>r</code>行第<code>c</code>列上下左右四个数的和，当然这是要在范围内，这里需要一个判断。而我的代码实现当中，是将这一步第<code>r</code>行第<code>c</code>列上下左右四个数加到下一步去。<br>较为复杂的我认为是在对于边界一圈的情况的考虑。如果球走到边界上了，剩余的步数至少还有一步，那他就可以出界，而且有多少种情况能走到边界的这个位置就有多少种出界的情况。但就如题目中的示例那样，边界的不同位置出界的可能i性是不同的。所以，我是在循环当中，先判断这个位置是不是边界以及是哪一种边界，如果是，再判断这个位置上是不是0，如果不是0，说明可以出界，那就将它加到出界总数去，一种边界加一次，这样就解决了边界不同位置有不同出界的可能性。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def findPaths(m, n, maxMove, startRow, startColumn):</span><br><span class="line">    if maxMove == 0:</span><br><span class="line">        return 0</span><br><span class="line">    dp = [[[0 for c in range(n)] for r in range(m)] for move in range(maxMove)]</span><br><span class="line">    outCounts = 0</span><br><span class="line">    dp[0][startRow][startColumn] = 1</span><br><span class="line">    for move in range(maxMove):</span><br><span class="line">        for r in range(m):</span><br><span class="line">            for c in range(n):</span><br><span class="line">                if r == 0 or c == 0 or r == m-1 or c == n-1:</span><br><span class="line">                    t = dp[move][r][c]</span><br><span class="line">                    if t != 0:</span><br><span class="line">                        if r-1 &lt; 0:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if c-1 &lt; 0:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if r+1 == m:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if c+1 == n:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                if move == maxMove-1:</span><br><span class="line">                    continue</span><br><span class="line">                for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:</span><br><span class="line">                    if i &gt;= 0 and i &lt; m and j &gt;= 0 and j &lt; n:</span><br><span class="line">                        dp[move+1][r][c] += dp[move][i][j]</span><br><span class="line"></span><br><span class="line">    return outCounts % (10**9+7)</span><br></pre></td></tr></table></figure>
<h3 id="方法二：-卷积"><a href="#方法二：-卷积" class="headerlink" title="方法二： 卷积"></a>方法二： 卷积</h3><p>大佬都在评论区。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findPaths</span>(<span class="params">m, n, maxMove, startRow, startColumn</span>):</span><br><span class="line">    <span class="keyword">if</span> maxMove &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a = numpy.zeros((m, n), )</span><br><span class="line">    a[startRow, startColumn] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    b = numpy.zeros((<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">int</span>)</span><br><span class="line">    b[<span class="number">0</span>][<span class="number">1</span>] = b[<span class="number">1</span>][<span class="number">0</span>] = b[-<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>][-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(a)</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(maxMove):</span><br><span class="line">        ans += (a[:, <span class="number">0</span>].<span class="built_in">sum</span>() + a[:, -<span class="number">1</span>].<span class="built_in">sum</span>() +</span><br><span class="line">                a[<span class="number">0</span>, :].<span class="built_in">sum</span>() + a[-<span class="number">1</span>, :].<span class="built_in">sum</span>()) % <span class="number">1_000_000_007</span></span><br><span class="line">        a = scipy.signal.convolve2d(a, b, <span class="string">&#x27;same&#x27;</span>) % <span class="number">1_000_000_007</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(ans) % <span class="number">1_000_000_007</span></span><br></pre></td></tr></table></figure></p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fXAdy9"><img src="https://z3.ax1x.com/2021/08/20/fXAdy9.jpg" alt="t提交记录1.jpg"></a><br><a href="https://imgtu.com/i/fXAaQJ"><img src="https://z3.ax1x.com/2021/08/20/fXAaQJ.jpg" alt="提交记录2.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>动态规划</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_787. K 站中转内最便宜的航班</title>
    <url>/2021/08/27/Leetcode-787-K-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>787. K 站中转内最便宜的航班<br>难度：中等</p>
<p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组&nbsp;<code>flights</code> ，其中&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> ，表示该航班都从城市 <code>from<sub>i</sub></code> 开始，以价格 <code>price<sub>i</sub></code> 抵达 <code>to<sub>i</sub></code>。</p>

<p>现在给定所有的城市和航班，以及出发城市 <code>src</code> 和目的地 <code>dst</code>，你的任务是找到出一条最多经过 <code>k</code>&nbsp;站中转的路线，使得从 <code>src</code> 到 <code>dst</code> 的 <strong>价格最便宜</strong> ，并返回该价格。 如果不存在这样的路线，则输出 <code>-1</code>。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入:</strong> 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
<strong>输出:</strong> 200
<strong>解释:</strong> 
城市航班图如下
<img style="height: 180px; width: 246px;" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt>

从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入:</strong> 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
<strong>输出:</strong> 500
<strong>解释:</strong> 
城市航班图如下
<img style="height: 180px; width: 246px;" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt>

从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 100</code></li>
    <li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>
    <li><code>flights[i].length == 3</code></li>
    <li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>
    <li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
    <li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
    <li>航班没有重复，且不存在自环</li>
    <li><code>0 &lt;= src, dst, k &lt; n</code></li>
    <li><code>src != dst</code></li>
</ul>


<h3 id="方法一-枚举"><a href="#方法一-枚举" class="headerlink" title="方法一: 枚举"></a>方法一: 枚举</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol>
<li>先创建一个字典，用于存从某一个地方出发，可以到哪些目的地以及花费是多少；</li>
<li>建立两个列表，分别存这一次可以从哪些地方出发，以及到这个地方已经用了的花费；</li>
<li>再建立两个临时列表，分别存在遍历出发地点的列时的目的地，以及到达目的地的的花费；</li>
<li>若遇到了目的地是<code>dst</code>，就将花费记录到另一个<code>ret</code>列表当中；</li>
<li>遍历完一遍出发列表后，<code>k</code>自减，将<code>3</code>中的列表分别赋给<code>2</code>中的列表；</li>
<li>直到<code>k</code>变为负数，输出<code>ret</code>中的最小值，如果没有，输出<code>-1</code>。<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findCheapestPrice</span>(<span class="params">n, flights, src, dst, k</span>):</span><br><span class="line">    dst_price = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s, d, p <span class="keyword">in</span> flights:</span><br><span class="line">        dst_price[s].append([d, p])</span><br><span class="line">        <span class="comment">#dst_price[d].append([s, p])</span></span><br><span class="line">    <span class="comment"># print(dst_price)</span></span><br><span class="line">    next_place = [src]</span><br><span class="line">    next_price = [<span class="number">0</span>]</span><br><span class="line">    temp_place = []</span><br><span class="line">    temp_price = []</span><br><span class="line">    kk = k</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">while</span> k &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> f, p0 <span class="keyword">in</span> <span class="built_in">zip</span>(next_place, next_price):</span><br><span class="line">            <span class="keyword">for</span> d, p <span class="keyword">in</span> dst_price[f]:</span><br><span class="line">                temp_place.append(d)</span><br><span class="line">                temp_price.append(p0+p)</span><br><span class="line">                <span class="comment"># print(f,d,temp_place)</span></span><br><span class="line">                <span class="comment"># print(temp_price)</span></span><br><span class="line">                <span class="keyword">if</span> d == dst:</span><br><span class="line">                    ret.append(p0+p)</span><br><span class="line">        next_place = temp_place</span><br><span class="line">        next_price = temp_price</span><br><span class="line">        <span class="comment"># print(next_place)</span></span><br><span class="line">        <span class="comment"># print(next_price,&quot;***&quot;)</span></span><br><span class="line">        temp_place = []</span><br><span class="line">        temp_price = []</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ret) <span class="keyword">if</span> ret != [] <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4>可能会出现两个地方来回的情况，造成超级大量的浪费计算。</li>
</ol>
<h3 id="方法二：-回溯"><a href="#方法二：-回溯" class="headerlink" title="方法二： 回溯"></a>方法二： 回溯</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findCheapestPrice</span>(<span class="params">n, flights, src, dst, k</span>):</span><br><span class="line">    dst_price = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s, d, p <span class="keyword">in</span> flights:</span><br><span class="line">        dst_price[s].append([d, p])</span><br><span class="line"></span><br><span class="line">    place = [src]</span><br><span class="line">    price = [<span class="number">0</span>]</span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">k, place, price</span>):</span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> d, p0 <span class="keyword">in</span> dst_price[place[-<span class="number">1</span>]]:</span><br><span class="line">            <span class="keyword">if</span> d == dst:</span><br><span class="line">                ret.append(price[-<span class="number">1</span>]+p0)</span><br><span class="line">            place.append(d)</span><br><span class="line">            price.append(price[-<span class="number">1</span>]+p0)</span><br><span class="line">            forward(k-<span class="number">1</span>, place, price)</span><br><span class="line">            place.pop()</span><br><span class="line">            price.pop()</span><br><span class="line">    forward(k, place, price)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ret) <span class="keyword">if</span> ret != [] <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="方法三：-动态规划"><a href="#方法三：-动态规划" class="headerlink" title="方法三： 动态规划"></a>方法三： 动态规划</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我刚开始的时候想，某次换成之后的最便宜的花费等于换成之前的那么多可能的站里的最便宜的花费加上这一段的花费，然而显然不是这样的，一度认为这一题不能用动态规划来做。而事实上这是错的，因为到某一站的最便宜花费应当等于到上一站的所有可能的站的最便宜花费分别加上这些上一站到这一站的花费之后所有花费当中最便宜的。还是用式子和代码来表示这些狗屁不通的话吧。</p>
<ol>
<li>状态:<code>dp[t][d]</code>表示第<code>t</code>次换乘时到<code>d</code>站的最小花费;</li>
<li>状态转移方程::<code>dp[t][d] = min(dp[t][d], dp[t-1][f]+cost)</code>,<code>cost</code>是<code>f</code>站到<code>d</code>站的花费,所以第<code>t</code>次换乘时到<code>d</code>站的最小花费等于所有能到<code>d</code>站的那些站到<code>d</code>站的最便宜花费加上那些站到<code>d</code>站的花费当中的最小值.</li>
<li>初始状态:<code>d[0][src]=0</code>.<br>其他注意的</li>
<li><code>k</code>次换乘,也就会有<code>k+2</code>个站,,注意相关循环的范围以及<code>dp</code>的设置;</li>
<li><code>float(&quot;inf&quot;)</code>表示无穷大.<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findCheapestPrice</span>(<span class="params">n, flights, src, dst, k</span>):</span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">2</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][src] = <span class="number">0</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> f, d, cost <span class="keyword">in</span> flights:</span><br><span class="line">            dp[t][d] = <span class="built_in">min</span>(dp[t][d], dp[t-<span class="number">1</span>][f]+cost)</span><br><span class="line">            <span class="keyword">if</span> d == dst <span class="keyword">and</span> dp[t][d] != <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">                ret.append(dp[t][d])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ret) <span class="keyword">if</span> ret != [] <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findCheapestPrice</span>(<span class="params">n, flights, src, dst, k</span>):</span><br><span class="line">    <span class="comment"># dst_price = defaultdict(list)</span></span><br><span class="line">    <span class="comment"># for s, d, p in flights:</span></span><br><span class="line">    <span class="comment">#     dst_price[s].append([d, p])</span></span><br><span class="line"></span><br><span class="line">    dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*n</span><br><span class="line">    ans = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># next_place = [src]</span></span><br><span class="line">    dp[src] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">2</span>):</span><br><span class="line">        g = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*n</span><br><span class="line">        <span class="keyword">for</span> f,d,cost <span class="keyword">in</span> flights:</span><br><span class="line">            g[d]=<span class="built_in">min</span>(g[d],dp[f]+cost)</span><br><span class="line">        <span class="comment"># temp = []</span></span><br><span class="line">        <span class="comment"># for f in next_place:</span></span><br><span class="line">        <span class="comment">#     for d, p in dst_price[f]:</span></span><br><span class="line">        <span class="comment">#         g[d] = min(g[d], dp[f]+p)</span></span><br><span class="line">        <span class="comment">#         temp.append(d)</span></span><br><span class="line">            <span class="keyword">if</span> d == dst:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, g[d])</span><br><span class="line">        dp = g</span><br><span class="line">        <span class="comment"># next_place = temp</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ans == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hAHnSS"><img src="https://z3.ax1x.com/2021/08/24/hAHnSS.jpg" alt="航班换乘提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_789.逃脱阻碍者</title>
    <url>/2021/08/22/Leetcode-789-%E9%80%83%E8%84%B1%E9%98%BB%E7%A2%8D%E8%80%85/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>789. 逃脱阻碍者<br>难度：中等</p>
<p>你在进行一个简化版的吃豆人游戏。你从 <code>[0, 0]</code> 点开始出发，你的目的地是&nbsp;<code>target = [x<sub>target</sub>, y<sub>target</sub>]</code> 。地图上有一些阻碍者，以数组 <code>ghosts</code> 给出，第 <code>i</code> 个阻碍者从&nbsp;<code>ghosts[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;出发。所有输入均为 <strong>整数坐标</strong> 。</p>

<p>每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 <strong>1 个单位</strong> 的新位置。当然，也可以选择 <strong>不动</strong> 。所有动作 <strong>同时</strong> 发生。</p>

<p>如果你可以在任何阻碍者抓住你 <strong>之前</strong> 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者同时到达了一个位置（包括目的地）都不算是逃脱成功。</p>

<p>只有在你有可能成功逃脱时，输出 <code>true</code> ；否则，输出 <code>false</code> 。</p>
&nbsp;

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>ghosts = [[1,0],[0,3]], target = [0,1]
<strong>输出：</strong>true
<strong>解释：</strong>你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。 
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>ghosts = [[1,0]], target = [2,0]
<strong>输出：</strong>false
<strong>解释：</strong>你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。 
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>ghosts = [[2,0]], target = [1,0]
<strong>输出：</strong>false
<strong>解释：</strong>阻碍者可以和你同时达到目的地。 
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>ghosts = [[5,0],[-10,-2],[0,-5],[-2,-2],[-7,1]], target = [7,7]
<strong>输出：</strong>false
</pre>

<p><strong>示例 5：</strong></p>

<pre><strong>输入：</strong>ghosts = [[-1,0],[0,1],[-1,0],[0,1],[-1,0]], target = [0,0]
<strong>输出：</strong>true
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= ghosts.length &lt;= 100</code></li>
    <li><code>ghosts[i].length == 2</code></li>
    <li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
    <li>同一位置可能有 <strong>多个阻碍者</strong> 。</li>
    <li><code>target.length == 2</code></li>
    <li><code>-10<sup>4</sup> &lt;= x<sub>target</sub>, y<sub>target</sub> &lt;= 10<sup>4</sup></code></li>
</ul>


<h3 id="方法：-曼哈顿距离"><a href="#方法：-曼哈顿距离" class="headerlink" title="方法： 曼哈顿距离"></a>方法： 曼哈顿距离</h3><p>刚过十二点，看完题目是懵的，这是要干嘛？没有思路，去看题解，曼哈顿距离又是什么鬼？于是去B站上找一下曼哈顿距离的讲解，知道了就是两个点之间的横坐标距离与纵坐标距离的和。那这和解题有什么关系呢？上床在睡前想了一下，发现其实并不难。<br>题目中的情况虽然看起来很多很复杂，但其实要解决的就是”我“能不能比幽灵更快地到达目的地。因为中途被拦截地情况，也能变为让拦截者到了目的地之后等”我“，结果是一样的。因此，就是要考虑”我“的起点到目的地的曼哈顿距离是不是比所有幽灵到目的地的曼哈顿距离小。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">escapeGhosts</span>(<span class="params">ghosts, target</span>):</span><br><span class="line">    target_x, target_y = target</span><br><span class="line">    L = <span class="built_in">abs</span>(target_x)+<span class="built_in">abs</span>(target_y)</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> ghosts:</span><br><span class="line">        l = <span class="built_in">abs</span>(x-target_x)+<span class="built_in">abs</span>(y-target_y)</span><br><span class="line">        <span class="keyword">if</span> l &lt;= L:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><br>还有一行的版本：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">escapeGhosts</span>(<span class="params">self, ghosts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>([<span class="built_in">abs</span>(target[<span class="number">0</span>])+<span class="built_in">abs</span>(target[<span class="number">1</span>]) &lt; <span class="built_in">abs</span>(ghost[<span class="number">0</span>]-target[<span class="number">0</span>])+<span class="built_in">abs</span>(ghost[<span class="number">1</span>]-target[<span class="number">1</span>]) <span class="keyword">for</span> ghost <span class="keyword">in</span> ghosts])</span><br><span class="line"></span><br><span class="line">作者：luanhz</span><br><span class="line">链接：https://leetcode-cn.com/problems/escape-the-ghosts/solution/wei-jin-zhe-sheng-pythonyi-xing-dai-ma-by-luanz/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。<br>元素除了是 0、空、None、False 外都算 True。</p>
</blockquote>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hSCRQe"><img src="https://z3.ax1x.com/2021/08/22/hSCRQe.jpg" alt="逃脱阻碍者提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>曼哈顿距离</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_797. 所有可能的路径</title>
    <url>/2021/08/26/Leetcode-797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>797. 所有可能的路径<br>难度：中等</p>
<p>给你一个有&nbsp;<code>n</code>&nbsp;个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code>&nbsp;到节点 <code>n-1</code>&nbsp;的路径并输出（<strong>不要求按特定顺序</strong>）</p>

<p>二维数组的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code> 号节点所能到达的下一些节点，空就是没有下一个结点了。</p>

<p>译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img style="height: 242px; width: 242px;" src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt></p>

<pre><strong>输入：</strong>graph = [[1,2],[3],[3],[]]
<strong>输出：</strong>[[0,1,3],[0,2,3]]
<strong>解释：</strong>有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3
</pre>

<p><strong>示例 2：</strong></p>

<p><img style="height: 301px; width: 423px;" src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" alt></p>

<pre><strong>输入：</strong>graph = [[4,3,1],[3,2,4],[3],[4],[]]
<strong>输出：</strong>[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>graph = [[1],[]]
<strong>输出：</strong>[[0,1]]
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>graph = [[1,2,3],[2],[3],[]]
<strong>输出：</strong>[[0,1,2,3],[0,2,3],[0,3]]
</pre>

<p><strong>示例 5：</strong></p>

<pre><strong>输入：</strong>graph = [[1,3],[2],[3],[]]
<strong>输出：</strong>[[0,1,2,3],[0,3]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>n == graph.length</code></li>
    <li><code>2 &lt;= n &lt;= 15</code></li>
    <li><code>0 &lt;= graph[i][j] &lt; n</code></li>
    <li><code>graph[i][j] != i</code>（即，不存在自环）</li>
    <li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li>
    <li>保证输入为 <strong>有向无环图（DAG）</strong></li>
</ul>


<h3 id="方法一：-回溯-深度优先搜索（DFS）"><a href="#方法一：-回溯-深度优先搜索（DFS）" class="headerlink" title="方法一：  回溯/深度优先搜索（DFS）"></a>方法一：  回溯/深度优先搜索（DFS）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allPathsSourceTarget</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(graph)</span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">temp, node</span>):</span><br><span class="line">            <span class="keyword">if</span> node == n-<span class="number">1</span>:</span><br><span class="line">                ret.append(temp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[node]:</span><br><span class="line">                temp.append(i)</span><br><span class="line">                backtrack(temp, i)</span><br><span class="line">                temp.pop()</span><br><span class="line">        backtrack([<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>正常的回溯套路，需要注意的是：</p>
<ol>
<li>每个列表<code>apppend</code>的时候到底加的是什么东西；</li>
<li>开头的<code>0</code>的加上；</li>
<li><code>ret.append(temp[:])</code>用这种方式可以解决深浅拷贝的问题。</li>
</ol>
<h3 id="方法二：-宽度优先搜索（BFS）"><a href="#方法二：-宽度优先搜索（BFS）" class="headerlink" title="方法二： 宽度优先搜索（BFS）"></a>方法二： 宽度优先搜索（BFS）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allPathsSourceTarget</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line">        <span class="comment"># 创建一个先进先出的队列</span></span><br><span class="line">        q = Queue()</span><br><span class="line">        n = <span class="built_in">len</span>(graph)-<span class="number">1</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="comment"># 向队列中加入元素</span></span><br><span class="line">        q.put([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            <span class="comment"># 取出队列中的元素（因为是先进先出，所以是第一个）</span></span><br><span class="line">            tmp = q.get()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[tmp[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="keyword">if</span> i == n:</span><br><span class="line">                    ret.append(tmp+[i])</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                q.put(tmp+[i])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hKFuX8"><img src="https://z3.ax1x.com/2021/08/26/hKFuX8.md.jpg" alt="提交记录.md.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>回溯</tag>
        <tag>深度优先搜索（DFS）</tag>
        <tag>广度优先搜索（BFS）</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-688-骑士在棋盘上的概率</title>
    <url>/2022/02/18/Leetcode-688-%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>688. 骑士在棋盘上的概率<br>难度：中等</p>
<p>在一个&nbsp;<code>n x n</code>&nbsp;的国际象棋棋盘上，一个骑士从单元格 <code>(row, column)</code>&nbsp;开始，并尝试进行 <code>k</code> 次移动。行和列是 <strong>从 0 开始</strong> 的，所以左上单元格是 <code>(0,0)</code> ，右下单元格是 <code>(n - 1, n - 1)</code> 。</p>

<p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。</p>

<p><img style="height: 300px; width: 300px;" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png"></p>

<p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p>

<p>骑士继续移动，直到它走了 <code>k</code> 步或离开了棋盘。</p>

<p>返回 <em>骑士在棋盘停止移动后仍留在棋盘上的概率</em> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入:</strong> n = 3, k = 2, row = 0, column = 0
<strong>输出:</strong> 0.0625
<strong>解释:</strong> 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。
在每一个位置上，也有两种移动可以让骑士留在棋盘上。
骑士留在棋盘上的总概率是0.0625。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入:</strong> n = 1, k = 0, row = 0, column = 0
<strong>输出:</strong> 1.00000
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 25</code></li>
    <li><code>0 &lt;= k &lt;= 100</code></li>
    <li><code>0 &lt;= row, column &lt;= n</code></li>
</ul>

<h3 id="思路一：广度优先搜索（BFS）"><a href="#思路一：广度优先搜索（BFS）" class="headerlink" title="思路一：广度优先搜索（BFS）"></a>思路一：广度优先搜索（BFS）</h3><p>题目不是很难理解，容易想到BFS。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">	    <span class="keyword">def</span> <span class="title function_">knightProbability</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span>, row: <span class="built_in">int</span>, column: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        Dirs = [(-<span class="number">1</span>, -<span class="number">2</span>), (<span class="number">1</span>, -<span class="number">2</span>),</span><br><span class="line">                (-<span class="number">2</span>, -<span class="number">1</span>), (<span class="number">2</span>, -<span class="number">1</span>),</span><br><span class="line">                (-<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">                (-<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">2</span>)]</span><br><span class="line">        q = deque()</span><br><span class="line">        q.append((row, column, k))</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            r, c, kk = q.popleft()</span><br><span class="line">            <span class="comment"># # 取出kk==0，cnt+1</span></span><br><span class="line">            <span class="comment"># # 也就是，走到最后一步再计数</span></span><br><span class="line">            <span class="keyword">if</span> kk == <span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> Dirs:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= r + x &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= c + y &lt; n:</span><br><span class="line">                    q.append((r + x, c + y, kk - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> cnt / <span class="built_in">pow</span>(<span class="number">8</span>, k)</span><br></pre></td></tr></table></figure>
<p>但这也很容易地超出了时间限制。</p>
<h3 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a>思路二：动态规划</h3><p>看了一下官解，没想到用的是动态规划。尝试自己写了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">knightProbability</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span>, row: <span class="built_in">int</span>, column: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        Dirs = [(-<span class="number">1</span>, -<span class="number">2</span>), (<span class="number">1</span>, -<span class="number">2</span>),</span><br><span class="line">                (-<span class="number">2</span>, -<span class="number">1</span>), (<span class="number">2</span>, -<span class="number">1</span>),</span><br><span class="line">                (-<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">                (-<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">2</span>)]</span><br><span class="line">        dp=[[[<span class="number">0</span>]* n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][row][column]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[step][i][j]&gt;<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">for</span> di,dj <span class="keyword">in</span> Dirs:</span><br><span class="line">                            ni,nj=i+di,j+dj</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span>&lt;=ni&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=nj&lt;n:</span><br><span class="line">                                dp[step+<span class="number">1</span>][ni][nj]+=<span class="number">1</span></span><br><span class="line">        cnt=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cnt+=<span class="built_in">sum</span>(dp[-<span class="number">1</span>][i])</span><br><span class="line">        <span class="built_in">print</span>(dp[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> cnt/<span class="built_in">pow</span>(<span class="number">8</span>,k)</span><br></pre></td></tr></table></figure>
<p>但是这样出现了错误，原因是在最后一步（<code>step=k-1</code>）的<code>dp[step+1][ni][nj]+=1</code>，加的只是这一步的情况，没有算上之前其实还有很多能到<code>i</code>,<code>j</code>的情况。</p>
<p>将<code>dp[step+1][ni][nj]+=1</code>修改为<code>dp[step + 1][ni][nj] += dp[step][i][j]</code>,成功通过！而且比官解的好！</p>
<p>官解：<br>它的状态值<code>dp[step][i][j]</code>指的是从<code>(i,j)</code>出发第<code>step</code>步后还在棋盘上的概率，状态转移方程是： $ dp[step][i][j] += \frac{1}{8} + \sum_{di,dj} dp[step-1][i+di][j+dj] , (di,dj)\in \{(-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)\}, 0\leq i,j,i+di,j+dj &lt;n $ 。<br>也不难理解，因为<code>(i,j)</code>下一步有8种可能的走法，那<code>(i+di,j+dj)</code>的概率就是 $\frac{1}{8}$ <code>(i,j)</code>的概率。换个角度讲也就是，有8种可能走到它<code>(i,j)</code>这，那走到<code>(i,j)</code>的概率就是$\sum_{di,dj} dp[step-1][i+di][j+dj]$。<br>那为什么最后只要输出<code>dp[k][row][column]</code>就好了呢？<br>我觉得可以倒过来走，以<code>n=3,k=1,row=0,colmn=0</code>为例，<code>(0,0)</code>在第1步往回走，有<code>0.25</code>的概率留在棋盘上，这就是答案。将初始值全部设为1，遍历所有点进行状态转移方程的计算，所得的结果<code>dp[k][i][j]</code>就是<code>(i,j)</code>走了<code>k</code>步之后仍然留在棋盘上的概率。将<code>k</code>扩展来解释状态转移方程，第<code>k</code>步<code>(i,j)</code>仍然留在棋盘的概率是由第<code>k-1</code>步对应8个点的状态值计算而来，每个点的状态值就是该店走那么多步仍然留在棋盘的概率。<br>当然了，超出棋盘范围的值都是0啦。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">knightProbability</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span>, row: <span class="built_in">int</span>, column: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        dp = [[[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> step == <span class="number">0</span>:</span><br><span class="line">                        dp[step][i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">for</span> di, dj <span class="keyword">in</span> ((-<span class="number">2</span>, -<span class="number">1</span>), (-<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, -<span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>), (-<span class="number">1</span>, -<span class="number">2</span>), (-<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, -<span class="number">2</span>), (<span class="number">1</span>, <span class="number">2</span>)):</span><br><span class="line">                            ni, nj = i + di, j + dj</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= ni &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= nj &lt; n:</span><br><span class="line">                                dp[step][i][j] += dp[step - <span class="number">1</span>][ni][nj] / <span class="number">8</span></span><br><span class="line">        <span class="keyword">return</span> dp[k][row][column]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/knight-probability-in-chessboard/solution/qi-shi-zai-qi-pan-shang-de-gai-lu-by-lee-2qhk/</span></span><br><span class="line"><span class="comment"># 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"># 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>
<p>我对官解的优化<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def knightProbability(self, n: int, k: int, row: int, column: int) -&gt; float:</span><br><span class="line">        Dirs = ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2))</span><br><span class="line">        dp = [[[0] * (n + 4) for _ in range(n + 4)] for _ in range(2)]</span><br><span class="line">        for i in range(2, 2 + n):</span><br><span class="line">            for j in range(2, 2 + n):</span><br><span class="line">                dp[0][i][j] = 1</span><br><span class="line">        for step in range(1, k + 1):</span><br><span class="line">            for i in range(2, 2 + n):</span><br><span class="line">                for j in range(2, 2 + n):</span><br><span class="line">                    dp[step % 2][i][j] = 0</span><br><span class="line">                    for di, dj in Dirs:</span><br><span class="line">                        ni, nj = i + di, j + dj</span><br><span class="line">                        dp[step % 2][i][j] += dp[1 - step % 2][ni][nj] / 8</span><br><span class="line">        return dp[k % 2][row + 2][column + 2]</span><br></pre></td></tr></table></figure></p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/H74Hte"><img src="https://s4.ax1x.com/2022/02/18/H74Hte.png" alt="提交记录.png"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-838-推多米诺</title>
    <url>/2022/02/21/Leetcode-838-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Leetcode中等</tag>
        <tag>双指针</tag>
        <tag>广度优先搜索（BFS）</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-969-煎饼排序</title>
    <url>/2022/02/19/Leetcode-969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>969. 煎饼排序</p>
<p>难度：中等</p>
<p>给你一个整数数组 <code>arr</code> ，请使用 <strong>煎饼翻转</strong><em> </em>完成对数组的排序。</p>

<p>一次煎饼翻转的执行过程如下：</p>

<ul>
   <li>选择一个整数 <code>k</code> ，<code>1 &lt;= k &lt;= arr.length</code></li>
   <li>反转子数组 <code>arr[0...k-1]</code>（<strong>下标从 0 开始</strong>）</li>
</ul>

<p>例如，<code>arr = [3,2,1,4]</code> ，选择 <code>k = 3</code> 进行一次煎饼翻转，反转子数组 <code>[3,2,1]</code> ，得到 <code>arr = [<strong>1</strong>,<strong>2</strong>,<strong>3</strong>,4]</code> 。</p>

<p>以数组形式返回能使 <code>arr</code> 有序的煎饼翻转操作所对应的 <code>k</code> 值序列。任何将数组排序且翻转次数在&nbsp;<code>10 * arr.length</code> 范围内的有效答案都将被判断为正确。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>[3,2,4,1]
<strong>输出：</strong>[4,2,4,3]
<strong>解释：</strong>
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 arr = [3, 2, 4, 1]
第一次翻转后（k = 4）：arr = [<strong>1</strong>, <strong>4</strong>, <strong>2</strong>, <strong>3</strong>]
第二次翻转后（k = 2）：arr = [<strong>4</strong>, <strong>1</strong>, 2, 3]
第三次翻转后（k = 4）：arr = [<strong>3</strong>, <strong>2</strong>, <strong>1</strong>, <strong>4</strong>]
第四次翻转后（k = 3）：arr = [<strong>1</strong>, <strong>2</strong>, <strong>3</strong>, 4]，此时已完成排序。 
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>[1,2,3]
<strong>输出：</strong>[]
<strong>解释：
</strong>输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
   <li><code>1 &lt;= arr.length &lt;= 100</code></li>
   <li><code>1 &lt;= arr[i] &lt;= arr.length</code></li>
   <li><code>arr</code> 中的所有整数互不相同（即，<code>arr</code> 是从 <code>1</code> 到 <code>arr.length</code> 整数的一个排列）</li>
</ul>


<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>一开始觉得有点懵，但稍微想了一下，其实简单，每一次都将未排序的部分中找到最大的那个，然后将它到第一个 的这部分翻转，<br>再将未排序的部分整体翻转，也就是每一次将未排序的最大的那个弄到已排序的开头。<br>这样的操作一共就是<code>2*len(arr)</code>，符合条件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pancakeSort</span>(<span class="params">self, arr</span>):</span><br><span class="line">        ans = []</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> m &lt; n:</span><br><span class="line">            max_i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - m):</span><br><span class="line">                <span class="keyword">if</span> arr[i] &gt; arr[max_i]:</span><br><span class="line">                    max_i = i</span><br><span class="line">            arr = arr[max_i::-<span class="number">1</span>] + arr[max_i + <span class="number">1</span>:]</span><br><span class="line">            arr = arr[n - m - <span class="number">1</span>::-<span class="number">1</span>] + arr[n - m::]</span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">            ans.append(max_i + <span class="number">1</span>)</span><br><span class="line">            ans.append(n - m + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>官解想法和我的是一样的。<br>只是实现上不一样。<br>我用的列表切片可真搞我。还有下标和range范围。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pancakeSort</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr), <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> arr[i] &gt; arr[index]:</span><br><span class="line">                    index = i</span><br><span class="line">            <span class="keyword">if</span> index == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            m = index</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((m + <span class="number">1</span>) // <span class="number">2</span>):</span><br><span class="line">                arr[i], arr[m - i] = arr[m - i], arr[i]  <span class="comment"># 原地反转</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">                arr[i], arr[n - <span class="number">1</span> - i] = arr[n - <span class="number">1</span> - i], arr[i]  <span class="comment"># 原地反转</span></span><br><span class="line">            ans.append(index + <span class="number">1</span>)</span><br><span class="line">            ans.append(n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/pancake-sorting/solution/jian-bing-pai-xu-by-leetcode-solution-rzzu/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<p>Python可以用切片，一般的可以用双指针来实现。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pancakeSort</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> arr[i] &gt; arr[k]:</span><br><span class="line">                    k = i</span><br><span class="line">            <span class="keyword">if</span> k == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i, j = <span class="number">0</span>, k</span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">                i, j = i + <span class="number">1</span>, j - <span class="number">1</span></span><br><span class="line">            i, j = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">                i, j = i + <span class="number">1</span>, j - <span class="number">1</span></span><br><span class="line">            ans.append(k + <span class="number">1</span>)</span><br><span class="line">            ans.append(n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_881. 救生艇</title>
    <url>/2021/08/26/Leetcode-881-%E6%95%91%E7%94%9F%E8%89%87/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>881. 救生艇<br>难度：中等</p>
<p>第&nbsp;<code>i</code>&nbsp;个人的体重为&nbsp;<code>people[i]</code>，每艘船可以承载的最大重量为&nbsp;<code>limit</code>。</p>

<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为&nbsp;<code>limit</code>。</p>

<p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>people = [1,2], limit = 3
<strong>输出：</strong>1
<strong>解释：</strong>1 艘船载 (1, 2)
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>people = [3,2,2,1], limit = 3
<strong>输出：</strong>3
<strong>解释：</strong>3 艘船分别载 (1, 2), (2) 和 (3)
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>people = [3,5,3,4], limit = 5
<strong>输出：</strong>4
<strong>解释：</strong>4 艘船分别载 (3), (3), (4), (5)</pre>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;=&nbsp;people.length &lt;= 50000</code></li>
    <li><code>1 &lt;= people[i] &lt;=&nbsp;limit &lt;= 30000</code></li>
</ul>


<h3 id="方法一：-贪心-排序-双指针"><a href="#方法一：-贪心-排序-双指针" class="headerlink" title="方法一： 贪心=排序+双指针"></a>方法一： 贪心=排序+双指针</h3><p>将<code>people</code>数组排序之后，用双指针的方法来做。要使船的数量尽可能少，那就让一个船上的人尽可能多，也就是让体重大的，尽可能和一个体重轻的坐一个船。两个指针<code>i</code>和<code>j</code>，一个从轻往重走，一个从重往轻走，如果可以一起坐船，两个指针一起动，<code>boats</code>计数自增；如果两个不能一起坐船，那就重的指针移动，计数自增；直到两个指针重合，这时候，计数还需要再自增一次。<br>贪心相当于思想，排序+双指针是具体的实现方法。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numRescueBoats</span>(<span class="params">people, limit</span>):</span><br><span class="line">    people.sort()</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(people)-<span class="number">1</span></span><br><span class="line">    boats = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> people[i]+people[j] &gt; limit:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            boats+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            boats+=<span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==j:</span><br><span class="line">            boats+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> boats</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numRescueBoats</span>(<span class="params">self, people: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        people.sort()</span><br><span class="line">        light, heavy = <span class="number">0</span>, <span class="built_in">len</span>(people) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> light &lt;= heavy:</span><br><span class="line">            <span class="keyword">if</span> people[light] + people[heavy] &gt; limit:</span><br><span class="line">                heavy -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                light += <span class="number">1</span></span><br><span class="line">                heavy -= <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/boats-to-save-people/solution/jiu-sheng-ting-by-leetcode-solution-0nsp/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
<h3 id="方法二：-贪心"><a href="#方法二：-贪心" class="headerlink" title="方法二： 贪心"></a>方法二： 贪心</h3><p>这其实使我首先想到的方法，但。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numRescueBoats</span>(<span class="params">people, limit</span>):</span><br><span class="line">    d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    i, j = limit+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> people:</span><br><span class="line">        d[w] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; w:</span><br><span class="line">            i = w</span><br><span class="line">        <span class="keyword">if</span> j &lt; w:</span><br><span class="line">            j = w</span><br><span class="line">    boats = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> d[j]==<span class="number">0</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> d[i] == <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> i+j &gt; limit:</span><br><span class="line">            boats += d[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        m = <span class="built_in">min</span>(d[i], d[j])</span><br><span class="line">        boats += m</span><br><span class="line">        d[i] -= m</span><br><span class="line">        d[j] -= m</span><br><span class="line">        <span class="comment"># i += (1-d[i]/1)</span></span><br><span class="line">        <span class="comment"># # if d[i]==0:</span></span><br><span class="line">        <span class="comment"># #     i-=1</span></span><br><span class="line">        <span class="comment"># j -= (1-d[j]/1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i &lt;= limit/<span class="number">2</span>:</span><br><span class="line">        boats += (d[i]+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        boats += d[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boats</span><br></pre></td></tr></table></figure><br>说明：<br>这里的做法是先统计了每种体重的人数，然后再用双指针的方法根据人数来做。<br>每次进入循环的时候，都要先判断对应体重的人数是不是0，这是因为，如果是0而没有先做处理的话，会出现<code>if i+j &gt; limit:</code>依然被执行的情况。<br>以为这种方法会减少时间消耗，然而并没有。</p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hKF2jK"><img src="https://z3.ax1x.com/2021/08/26/hKF2jK.jpg" alt="救生艇提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Leetcode中等</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda</title>
    <url>/2021/08/29/cuda/</url>
    <content><![CDATA[<p>pip安装<br>pip3 install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio===0.9.0 -f <a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a></p>
<p>conda<br>NOTE: ‘conda-forge’ channel is required for cudatoolkit 11.1<br>conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch -c conda-forge</p>
<p><a href="https://pytorch.org/">https://pytorch.org/</a></p>
]]></content>
      <categories>
        <category>一些命令</category>
      </categories>
      <tags>
        <tag>cuda</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo命令.md</title>
    <url>/2021/10/03/hexo%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>B站视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.999.0.0</a></p>
<h5 id="安装配置hexo"><a href="#安装配置hexo" class="headerlink" title="安装配置hexo"></a>安装配置hexo</h5><ol>
<li>安装nodejs和npm<br> nodejs网站：nodejs.org<br> 可以用<code>nodejs -v</code> <code>npm -v</code>检查是否安装成功</li>
<li>安装淘宝镜像cnpm<br> <code>npm  insatll -g cnpm --registry=https://registry.npm.taobao.org</code><br> <code>-g</code>全局安装<br> <code>cnpm -v</code>检查是否安装成功</li>
<li>安装hexo框架<br> <code>cnpm install -g hexo-cli</code><br> <code>hexo -v</code></li>
</ol>
<h5 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h5><ol>
<li>新建一个文件夹， 进入该文件夹，<code>hexo init</code></li>
<li>或者 <code>hexo init (名字)</code>;</li>
<li>启动 start/service<br> <code>hexo s</code></li>
<li>清理一下<br> <code>hexo clean</code></li>
<li>生成<br> <code>hexo g</code></li>
<li>安装git插件<br> <code>cnpm install --save hexo-deployer-git</code></li>
<li>上传<br> <code>hexo d</code><br> 简单点可以和生成一起：<code>hexo g -d</code></li>
<li>标签页<br> <code>hexo n page tags</code></li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode题解</title>
    <url>/2021/08/17/Leetcode%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>因为既想在Github上传题解思路和代码，又想在博客上传，但保证两边同步好麻烦，所以这里列一个列表，链接到Github上。</p>
<h3 id="301-400"><a href="#301-400" class="headerlink" title="301-400"></a>301-400</h3><ul>
<li><a href="https://github.com/shengrihui/Leetcode/blob/c396f399bcca39c40923411eabf0306c7d89739f/3/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.md">345. 反转字符串中的元音字母</a><h3 id="501-600"><a href="#501-600" class="headerlink" title="501~600"></a>501~600</h3></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/5acbc6232b0a90c9cf3beaaa4972ba3e9174d7ab/5/526.%20%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/526.%20%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97.md">526.优美的排列</a></li>
<li>[541. 反转字符串 ](<a href="https://github.com/shengrihui/Leetcode/blob/c5b27e27baac035e0fddb3e64867fab88630da82/5/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II.md">https://github.com/shengrihui/Leetcode/blob/c5b27e27baac035e0fddb3e64867fab88630da82/5/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II.md</a></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/96ca3695c85441f9cc189b123944249f5bb81bbc/5/551.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20I/551.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20I_%E9%A2%98%E8%A7%A3.md">551. 学生出勤记录 I_题解</a></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/c396f399bcca39c40923411eabf0306c7d89739f/5/552.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20II/552.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20II.md">552. 学生出勤记录 II</a></li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2021/08/05/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 支持两种形式的标题, [Setext] [1] 和 [atx] [2].<br>Setext 样式的标题使用的等号来表示一级标题, 使用连字符表示二级标题. 例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">&gt;This is an H1</span></span><br><span class="line"><span class="section">=============</span></span><br><span class="line">This is an H2</span><br><span class="line">&gt;-------------</span><br></pre></td></tr></table></figure>
<p>任意长度的 = 或 - 都是可以的.<br>Atx 样式的标题每行开头使用 1-6 井号, 对应 1-6 级标题. 例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure>
<p>可选地, 你可以 “关闭” atx 样式的标题. 这纯粹是美化需要 — 如果你认为这样美观一些就用吧. 关&gt;闭标签的井号数量甚至不需要和起始位置的匹配. (起始的井号数量决定了标题的级别.) :</p>
<h1 id="This-is-an-H1"><a href="#This-is-an-H1" class="headerlink" title="This is an H1"></a>This is an H1</h1><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2"></a>This is an H2</h2><h3 id="This-is-an-H3"><a href="#This-is-an-H3" class="headerlink" title="This is an H3"></a>This is an H3</h3><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题 ##</span></span><br><span class="line"><span class="section">这也是一级标题</span></span><br><span class="line"><span class="section">=========</span></span><br><span class="line"><span class="section">这是二级标题</span></span><br><span class="line"><span class="section">-------</span></span><br></pre></td></tr></table></figure>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h1 id="这也是一级标题"><a href="#这也是一级标题" class="headerlink" title="这也是一级标题"></a>这也是一级标题</h1><h2 id="这是二级标题-1"><a href="#这是二级标题-1" class="headerlink" title="这是二级标题"></a>这是二级标题</h2></blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 使用 email 样式的 &gt; 字符作为块引用. 如果你熟悉 email 消息中的引用段落, 那么你同样可以在 Markdown 中创建块引用. 最好对引用文本采取强制换行并在每一行行首放一个 &gt; :</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span></span><br><span class="line"><span class="quote">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span></span><br><span class="line"><span class="quote">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span></span><br><span class="line"><span class="quote">&gt; id sem consectetuer libero luctus adipiscing.</span></span><br></pre></td></tr></table></figure>
<p>Markdown 中可以简便地只在每一个需要强制换行的段落的首行前面加上一个 &gt; :</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span></span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span></span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>块引用可以嵌套 (例如, 块引用中包含块引用) , 只需添加额外层级的 &gt; 即可:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is the first level of quoting.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; This is nested blockquote.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Back to the first level.</span></span><br></pre></td></tr></table></figure>
<p>块引用可以包含 Markdown 元素, 包括标题, 列表和代码块:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; ## This is a header.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 1.   This is the first list item.</span></span><br><span class="line"><span class="quote">&gt; 2.   This is the second list item.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Here&#x27;s some example code:</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;     return shell<span class="emphasis">_exec(&quot;echo $input | $markdown_</span>script&quot;);</span></span><br><span class="line">&gt;、</span><br></pre></td></tr></table></figure>
<p>任何合适的文本编辑器都应该可以很方便的创建 email 样式的块引用. 例如, 用 BBEdit 就可以选取文本然后从 ‘Text’ 菜单中选择 ‘Increase Quote Level’.</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是一级引用</span><br><span class="line">&gt;&gt;这是二级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;这是好多级引用</span><br></pre></td></tr></table></figure>
<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><blockquote>
<p>这是一级引用</p>
<blockquote>
<p>这是二级引用</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是好多级引用</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="文档-2"><a href="#文档-2" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 支持有序列表和无序列表.</p>
<p>无序列表使用星号, 加号, 和连字符 — 这些符号是可互换的 — 最为列表标记:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Red</span><br><span class="line"><span class="bullet">*</span>   Green</span><br><span class="line"><span class="bullet">*</span>   Blue</span><br></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span>   Red</span><br><span class="line"><span class="bullet">+</span>   Green</span><br><span class="line"><span class="bullet">+</span>   Blue</span><br></pre></td></tr></table></figure>
<p>以及:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span>   Red</span><br><span class="line"><span class="bullet">-</span>   Green</span><br><span class="line"><span class="bullet">-</span>   Blue</span><br></pre></td></tr></table></figure>
<p>有序列表使用数字加句号:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Bird</span><br><span class="line"><span class="bullet">2.</span>  McHale</span><br><span class="line"><span class="bullet">3.</span>  Parish</span><br></pre></td></tr></table></figure>
<p>需要注意的是这里的数字序号对于最终生成 HTML 是没有影响的. 这里 Markdown 输出的 HTML 列表是:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>McHale<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Parish<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即使你把列表写成这样:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Bird</span><br><span class="line"><span class="bullet">1.</span>  McHale</span><br><span class="line"><span class="bullet">1.</span>  Parish</span><br></pre></td></tr></table></figure>
<p>甚至这样:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">3.</span> Bird</span><br><span class="line"><span class="bullet">1.</span> McHale</span><br><span class="line"><span class="bullet">8.</span> Parish</span><br></pre></td></tr></table></figure>
<p>你都讲得到相同的 HTML 输出. 重点是, 如果你希望你的 Markdown 源码中的列表序号匹配输出的 HTML 列表序号, 你应该使用正常的序号 . 当然, 如果你想简单点, 也可不必这么做.</p>
<p>即使你使用错误的列表序号, 最终生成的列表仍然会以序号 1 开始. 在未来的版本里, Markdown 可能支持以任意数字作为列表起始序号.</p>
<p>List 标记通常从左边开始, 可以用三个及以上的空格来缩进. List 标记后面应该跟一个以上的空格或者一个水平制表符.</p>
<p>为了使列表更美观, 可以用悬挂缩进来格式化列表项:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line"><span class="code">    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span></span><br><span class="line"><span class="code">    viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"><span class="code">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span></span><br><span class="line"><span class="code">    Suspendisse id sem consectetuer libero luctus adipiscing.</span></span><br><span class="line"><span class="code">    但是这不是必须的:</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span>   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"><span class="bullet">*</span>   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>如果列表项中包含空行, Markdown 会在 HTML 输出中用 </p><p> 来包裹他们. 例如, 下面的输入:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Bird</span><br><span class="line"><span class="bullet">*</span>   Magic</span><br></pre></td></tr></table></figure>
<p>会输出:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Magic<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Bird</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   Magic</span><br></pre></td></tr></table></figure>
<p>会输出:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Magic<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>列表项可能包含多个段落. 列表项中的每个段落都必须用 4 个空格或一个水平制表符来缩进:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line"><span class="code">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span></span><br><span class="line"><span class="code">    mi posuere lectus.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span></span><br><span class="line"><span class="code">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span></span><br><span class="line"><span class="code">    sit amet velit.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span>  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>同上, 悬挂缩进只是为了更美观, 而非强制要求:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line"><span class="code">    This is the second paragraph in the list item. You&#x27;re</span></span><br><span class="line"><span class="code">only required to indent the first line. Lorem ipsum dolor</span></span><br><span class="line"><span class="code">sit amet, consectetuer adipiscing elit.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span>   Another item in the same list.</span><br></pre></td></tr></table></figure>
<p>如果列表项中包含块注释 , 块注释标记 &gt; 需要缩进:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line"><span class="code">    &gt; This is a blockquote</span></span><br><span class="line"><span class="code">    &gt; inside a list item.</span></span><br></pre></td></tr></table></figure>
<p>如果列表项中有代码块, 代码块需要 双倍 缩进— 8 个空格或者两个水平制表符:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> A list item with a code block:</span><br><span class="line"></span><br><span class="line"><span class="code">      &lt;code goes here&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时候无意中出发有序列表, 如下面这样的代码:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1986.</span> What a great season.</span><br></pre></td></tr></table></figure>
<p>即使, 如果一行开头满足 number-period-space 模式. 可以通过转义点号来避免这种情况:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1986\. What a great season.</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>略</p>
<h2 id="代码块和代码"><a href="#代码块和代码" class="headerlink" title="代码块和代码"></a>代码块和代码</h2><h3 id="文档-3"><a href="#文档-3" class="headerlink" title="文档"></a>文档</h3><ul>
<li>代码块<blockquote>
<p>预格式化的代码块用于输出编程语言和标记语言. 不同于普通段落, 代码块中的行会被原样呈现. Markdown 会用 <pre> 和 <code> 标签包围代码块.</code></pre></p>
<p>要在 Markdown 中插入代码块, 只需要将每一行都缩进 4 个空格或者 1 个水平制表符. 例如, 下面的输入:</p>
<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre><p>Markdown 会生成:</p>
<pre><code>&lt;p&gt;This is a normal paragraph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>只有一级缩进 — 4 个空格或者 1 个水平制表符 — 会从代码块中的每一行中移除. 例如:</p>
<pre><code>Here is an example of AppleScript:

tell application &quot;Foo&quot;
    beep
end tell
</code></pre><p>会生成:</p>
<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre></blockquote>
</li>
<li>代码<blockquote>
<p>要输出一个代码片段, 需要使用重音符号 (`). 不同于预格式的代码块, 代码片段只是在普通段落中标识出代码. 例如:</p>
<pre><code> Use the `printf()` function.
</code></pre><p>会生成:</p>
<pre><code> &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre><p>要在代码片段中包含字面量的重音符号, 可以使用多个重音符号作为起始和结束标记:</p>
<pre><code> ``There is a literal backtick (`) here.``
</code></pre><p>会生成:</p>
<pre><code> &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre><p>包含代码片段的重音符号可以包含空格 — 起始标记后一个, 结束标记前一个. 这使你可以在代码片段开始和结束位置使用重音符号的字面量:</p>
<pre><code> A single backtick in a code span: `` ` ``

 A backtick-delimited string in a code span: `` `foo` ``
</code></pre><p>会生成:</p>
<pre><code> &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

 &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre><p>在代码片段中, 英镑符号和尖括号会被转换成相应的字符实体, 这使得包含 HTML 标签很容易. Markdown 会将下面的代码:</p>
<pre><code> Please don&#39;t use any `&lt;blink&gt;` tags.
</code></pre><p> 转成:</p>
<pre><code> &lt;p&gt;Please don&#39;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre><p>这样写:</p>
<pre><code> `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre><p>会生成:</p>
<pre><code> &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
 equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre></blockquote>
</li>
</ul>
<h3 id="文档总结和补充"><a href="#文档总结和补充" class="headerlink" title="文档总结和补充"></a>文档总结和补充</h3><ol>
<li>选中写好了的代码，然后tab缩进就好了。</li>
<li>还有一种是通过一对  `` (英文状态下tab键上面那个) 或者 <del>~  (英文状态下shift+tab上面那个) 将代码包起来。三个反撇号和三个波浪号各一行。再第一个```或</del>~后可以加上代码的语言，这样可以有更好的显示效果。</li>
</ol>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5>  要加粗的文字左右分别用两个*号包起来</li>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5>  要倾斜的文字左右分别用一个*号包起来</li>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5> 要倾斜和加粗的文字左右分别用三个*号包起来</li>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5>  要加删除线的文字左右分别用两个~~号包起来<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4>  <strong>这是加粗的文字</strong><br>  <em>这是倾斜的文字</em><br>  <strong><em>这是倾斜加粗的文字</em></strong><br>  <del>这是添加删除线</del><h4 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h4><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是倾斜加粗的文字</em></strong><br><del>这是添加删除线</del></li>
</ul>
<h3 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.  分割线"></a>4.  分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><pre><code>---
----
***
****
</code></pre><h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><hr>
<hr>
<h3 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h3><h4 id="语法-amp-示例"><a href="#语法-amp-示例" class="headerlink" title="语法&amp;示例"></a>语法&amp;示例</h4><pre><code>本地：
  ![狗]（markdown语法/dog.jpg &quot;狗&quot;）
</code></pre><h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><img src="/.io//08/05/markdown%E8%AF%AD%E6%B3%95/dog.jpg" class title="狗">
<p><img src="/.io//dog.jpg" width="256" height="256"></p>
<p> <img src="/.io//08/05/markdown%E8%AF%AD%E6%B3%95/dog.jpg" class title="狗">{:width=”30px” height=”10px”}</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉公式</title>
    <url>/2022/02/20/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h3><p>$ e^{i\theta} = \cos\theta + i\sin\theta$ ，当 $\theta=\pi$ 时，$e^{i\pi} + 1 =0$.</p>
<h3 id="证明一：求导"><a href="#证明一：求导" class="headerlink" title="证明一：求导"></a>证明一：求导</h3><p>设 $f(\theta)=\frac{e^i\theta}{i\sin\theta+\cos\theta}$ ,对 $ f(\theta)$ 求一阶导，</p>
<script type="math/tex; mode=display">
\begin{aligned}
f'(\theta)&=\frac{ie^{i\theta}(i\sin\theta+\cos\theta)-e^{i\theta}(i\cos\theta-\sin\theta)}{(i\sin\theta+\cos\theta)^{2}} \\
&=\frac{-e^{i\theta}\sin\theta+ie^{i\theta}\cos\theta-ie^{i\theta}\cos\theta+e^{i\theta}\sin\theta}{(i\sin\theta+\cos\theta)^{2}} \\
&=0\\
\end{aligned}</script><p>因为 $f’(\theta)=0$ ，所以 $f(\theta)$ 是一个常数。取$\theta=0$:</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(0)&=\frac{e^{i·0}}{i\sin0+\cos0}\\
&=\frac{1}{0+1}\\
&=1\\
\end{aligned}</script><p>所以，$e^{i\theta} = \cos\theta + i\sin\theta$。<br>同时，也容易得到 $e^{i\theta} $ 和 $  \cos\theta + i\sin\theta$ 都不等于0。<br>将 $f(\theta)$ 设为 $f(\theta)=\frac{i\sin\theta+\cos\theta}{e^i\theta}$ 是一样的。</p>
<h3 id="证明二：函数幂级数展开"><a href="#证明二：函数幂级数展开" class="headerlink" title="证明二：函数幂级数展开"></a>证明二：函数幂级数展开</h3><h5 id="泰勒展开式和麦克劳林展开式的简单推导"><a href="#泰勒展开式和麦克劳林展开式的简单推导" class="headerlink" title="泰勒展开式和麦克劳林展开式的简单推导"></a>泰勒展开式和麦克劳林展开式的简单推导</h5><p>将 $f(x)$ 展开为幂级数：</p>
<script type="math/tex; mode=display">
f(x)=a_0+a_1(x-x_0)+a_2(x-x_0)^2+a_3(x-x_0)^3+a_4(x-x_0)^4+a_5(x-x_0)^5+...+a_n(x-x_0)^n+...</script><p>对式子两边求导：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f'(x)&=a_1+2a_2(x-x_0)+3a_3(x-x_0)^2+4a_4(x-x_0)^3+...\\
f''(x)&=2a_2+3·2a_3(x-x_0)+4·3(x-x_0)^2+5a_5(x-x_0)^4+...\\
f'''(x)&=3·2a_3+4·3·2a_4(x-x_0)+5·4a_5(x-x_0)^3+...\\
...\\
\end{aligned}</script><p>令 $x=x_0$ ，计算 $a_0,a_1,a_3….$ ：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x_0)=a_0  &,a_0=f(x_0)\\
f'(x_0)=a_1 &,a_1=f'(x_0)\\
f''(x_0)=2a_2 &,a_2=\frac{f'(x_0)}{2!}\\
f'''(x_0)=3·2a_3 &,a_3=\frac{f'''(x_0)}{3!}\\
...\\
f^n(x_0)=n!a_n &,a_n=\frac{f^n(x_0)}{n!}\\
\end{aligned}</script><p>于是，</p>
<script type="math/tex; mode=display">
f(x)=\sum_{n=0}^{\infty}\frac{1}{n!}f^{(n)}(x_0)(x-x_0)^n,x\in U(x_0)</script><p>这就是泰勒级数。它成立的充要条件是它的余项极限是 0：</p>
<script type="math/tex; mode=display">
\lim_{n\to \infty}R_n(x)= \lim_{n\to\infty}\frac{1}{n!}f^{(n)}(x_0)(x-x_0)^n= 0</script><p>取 $x_0=0$ ，有麦克劳林展开式：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{n=0}^{\infty}\frac{1}{n!}f^{(n)}(0)x^n ,x\in (-r,r)</script><h5 id="推导欧拉公式"><a href="#推导欧拉公式" class="headerlink" title="推导欧拉公式"></a>推导欧拉公式</h5><p>根据麦克劳林展开式，我们可以有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin x&=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\frac{x^9}{9!}-...\\
\cos x&=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^8}{8!}-...\\
e^x&=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}+...
\end{aligned}</script><p>计算 $\sin x+\cos x$ ，得到：</p>
<script type="math/tex; mode=display">
\sin x+\cos x=1+x-\frac{x^2}{2!}-\frac{x^3}{3!}+\frac{x^4}{4!}+\frac{x^5}{5!}-\frac{x^6}{6!}-\frac{x^7}{7!}+\frac{x^8}{8!}+...</script><p>这与 $e^x$ 的区别在于符号上，随着 $x$ 的次数增加，符号的变化规律时 $+,-,-,+$ ，这正好符合虚数单位 $i$ 的符号变化规律。因此，考虑计算 $e^{ix}$ :</p>
<script type="math/tex; mode=display">
\begin{aligned}
e^{ix}&=1+ix+\frac{(ix)^2}{2!}+\frac{(ix)^3}{3!}+\frac{(ix)^4}{4!}+...\\
&=1+ix-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}+\frac{ix^5}{5!}-\frac{x^6}{6!}-\frac{ix^7}{7!}+\frac{x^8}{8!}...\\
&=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^8}{8!}-...\\
&   +i(x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\frac{x^9}{9!}-...)\\
&=\cos x+i\sin x
\end{aligned}</script><h3 id="应用：解方程-sin-x-2"><a href="#应用：解方程-sin-x-2" class="headerlink" title="应用：解方程 $ \sin x=2 $"></a>应用：解方程 $ \sin x=2 $</h3><p>其实就是想练习一下简单的 Latex 的公式编辑，这个直接放B站链接：<a href="https://www.bilibili.com/video/av32271249/">解方程 $ \sin x=2 $</a></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>next主题配置</title>
    <url>/2021/08/20/next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="04-正确姿势打开标签页和分类页"><a href="#04-正确姿势打开标签页和分类页" class="headerlink" title="04 正确姿势打开标签页和分类页"></a>04 正确姿势打开标签页和分类页</h4><ol>
<li>命令<code>hexo n page tags</code>,source文件夹中多出一个包含index.html的tags文件夹。这时候博客中的“标签就能打开了。</li>
<li>修改index.html文件。<code>title</code>改为<code>标签</code>，增加一行<code>type: tags</code>（这句不写标签页不会有标签）。</li>
<li>命令：<code>hexo n page categories</code>创建分类页。</li>
<li>修改categories里的index.html ，与之前类似。</li>
</ol>
<h4 id="05-主题样式的更改"><a href="#05-主题样式的更改" class="headerlink" title="05 主题样式的更改"></a>05 主题样式的更改</h4><p>在样式配置文件中修改<code>Schemes</code>项。</p>
<h4 id="04-设置主题头像"><a href="#04-设置主题头像" class="headerlink" title="04 设置主题头像"></a>04 设置主题头像</h4><p>主题配置文件中<code>Avatar</code>项</p>
<h4 id="07-更改作者和标题以及链接"><a href="#07-更改作者和标题以及链接" class="headerlink" title="07 更改作者和标题以及链接"></a>07 更改作者和标题以及链接</h4><h4 id="08-启用侧边栏社交链接"><a href="#08-启用侧边栏社交链接" class="headerlink" title="08 启用侧边栏社交链接"></a>08 启用侧边栏社交链接</h4><ul>
<li>主题配置文件的<code>Social</code>项。</li>
</ul>
<h4 id="09-启用友情链接"><a href="#09-启用友情链接" class="headerlink" title="09 启用友情链接"></a>09 启用友情链接</h4><p>主题配置文件中<code>links_settings</code>项。</p>
<h4 id="10-新建一篇文章"><a href="#10-新建一篇文章" class="headerlink" title="10 新建一篇文章"></a>10 新建一篇文章</h4><ul>
<li><code>hexo n 文章名</code> 新建一篇文章</li>
<li>在文章里添加标签和分类：<br>  tags:<pre><code> - xx
 - xx
    categories:
    xx
</code></pre></li>
</ul>
<h4 id="11-Markdown的使用"><a href="#11-Markdown的使用" class="headerlink" title="11 Markdown的使用"></a>11 Markdown的使用</h4><h4 id="12-开启文章打赏功能"><a href="#12-开启文章打赏功能" class="headerlink" title="12 开启文章打赏功能"></a>12 开启文章打赏功能</h4><p>主题配置文件中<code>reward</code>项。</p>
<h4 id="13-开启订阅公众号"><a href="#13-开启订阅公众号" class="headerlink" title="13 开启订阅公众号"></a>13 开启订阅公众号</h4><p>主题配置文件中<code>wechat Subscriber</code>项。</p>
<h4 id="14-设置头像是圆形可旋转"><a href="#14-设置头像是圆形可旋转" class="headerlink" title="14 设置头像是圆形可旋转"></a>14 设置头像是圆形可旋转</h4><ul>
<li>打开文件<code>..\themes\hexo-theme-next\source\css\_common\outline\sidebar\sidebar-author.sty</code>，对其中的参数进行修改。</li>
<li>在主题配置文件中修改： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># If true, the avatar will be dispalyed in circle.</span><br><span class="line">rounded: true</span><br><span class="line"># If true, the avatar will be rotated with the cursor.</span><br><span class="line">rotated: true</span><br></pre></td></tr></table></figure>
第一个是让头像在圆中显示，第二个是鼠标移上去后旋转。</li>
</ul>
<h4 id="15-首页设置文章阅读全文"><a href="#15-首页设置文章阅读全文" class="headerlink" title="15 首页设置文章阅读全文"></a>15 首页设置文章阅读全文</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excerpt:</span><br><span class="line">  depth: 3  #按层来算，也就是按代码块来算</span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: true</span><br></pre></td></tr></table></figure>
<h4 id="背景黑色"><a href="#背景黑色" class="headerlink" title="背景黑色"></a>背景黑色</h4><h4 id="fork-Github"><a href="#fork-Github" class="headerlink" title="fork Github"></a>fork Github</h4><p>打开<code>..\themes\hexo-theme-next\layout</code>中的文件<code>_layout.swig</code>。<br>在<a href="https://tholman.com/github-corners/">https://tholman.com/github-corners/</a> 中选一个样式，将代码复制到文件中的<code>&lt;/header&gt;</code>前，并修改称自己的GitHub链接。</p>
<h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><p>按官方文档的local search来。<a href="http://theme-next.iissnan.com/third-party-services.html">http://theme-next.iissnan.com/third-party-services.html</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python的一些内建函数和基本句法</title>
    <url>/2022/02/17/Python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8F%A5%E6%B3%95/</url>
    <content><![CDATA[<h3 id="any-和all"><a href="#any-和all" class="headerlink" title="any()和all()"></a><code>any()</code>和<code>all()</code></h3><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><code>any()</code>函数用来判断给定的迭代参数<code>iterable</code>中是否含有<code>True</code>，如果有（只要有一个），则返回<code>True</code>.<br>函数等价于：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">any</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<p><code>all()</code>函数用来判断给定的迭代参数<code>iterable</code>中是否全部是是<code>True</code>，如果是，则返回<code>True</code>。<br>函数等价于：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">all</span>(<span class="params">iterable</span>):</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><br><code>any()</code>：只要有一个<code>True</code>，就返回<code>True</code>；<br><code>all()</code>：全部是<code>True</code>，就返回<code>True</code>。<br><strong>注意</strong> ：空元组、空列表返回值为True，这里要特别注意。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>示例来自菜鸟教程。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">any</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])  <span class="comment"># 列表list，元素都不为空或0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])   <span class="comment"># 列表list，存在一个为空的元素</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([<span class="number">0</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">False</span>])        <span class="comment"># 列表list,元素全为0,&#x27;&#x27;,false</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>))  <span class="comment"># 元组tuple，元素都不为空或0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;d&#x27;</span>))   <span class="comment"># 元组tuple，存在一个为空的元素</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>((<span class="number">0</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">False</span>))        <span class="comment"># 元组tuple，元素全为0,&#x27;&#x27;,false</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>([]) <span class="comment"># 空列表</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">any</span>(()) <span class="comment"># 空元组</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])  <span class="comment"># 列表list，元素都不为空或0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])   <span class="comment"># 列表list，存在一个为空的元素</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([<span class="number">0</span>, <span class="number">1</span>，<span class="number">2</span>, <span class="number">3</span>])          <span class="comment"># 列表list，存在一个为0的元素</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>))  <span class="comment"># 元组tuple，元素都不为空或0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;d&#x27;</span>))   <span class="comment"># 元组tuple，存在一个为空的元素</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>((<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))          <span class="comment"># 元组tuple，存在一个为0的元素</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>([])             <span class="comment"># 空列表</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">all</span>(())             <span class="comment"># 空元组</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><br>下面示例来自CSDN。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(x**<span class="number">2</span> == <span class="number">16</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1706-球会落何处</title>
    <url>/2022/02/24/Leetcode-1706-%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>1706. 球会落何处<br>难诉：中等</p>
<p>用一个大小为 <code>m x n</code> 的二维网格 <code>grid</code> 表示一个箱子。你有 <code>n</code> 颗球。箱子的顶部和底部都是开着的。</p>

<p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p>

<ul>
    <li>将球导向右侧的挡板跨过左上角和右下角，在网格中用 <code>1</code> 表示。</li>
    <li>将球导向左侧的挡板跨过右上角和左下角，在网格中用 <code>-1</code> 表示。</li>
</ul>

<p>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 "V" 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p>

<p>返回一个大小为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是球放在顶部的第 <code>i</code> 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 <code>-1</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><strong><img style="width: 500px; height: 385px;" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/26/ball.jpg" alt></strong></p>

<pre><strong>输入：</strong>grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]
<strong>输出：</strong>[1,-1,-1,-1,-1]
<strong>解释：</strong>示例如图：
b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。
b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。
b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。
b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 "V" 形里。
b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 "V" 形里。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>grid = [[-1]]
<strong>输出：</strong>[-1]
<strong>解释：</strong>球被卡在箱子左侧边上。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]
<strong>输出：</strong>[0,1,2,3,4,-1]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == grid.length</code></li>
    <li><code>n == grid[i].length</code></li>
    <li><code>1 &lt;= m, n &lt;= 100</code></li>
    <li><code>grid[i][j]</code> 为 <code>1</code> 或 <code>-1</code></li>
</ul>

<h3 id="方法一：-模拟"><a href="#方法一：-模拟" class="headerlink" title="方法一： 模拟"></a>方法一： 模拟</h3><p>虽然是中等难度的题，但看完题后就马上想到了可以用DFS，不过再想想发现不是DFS而是模拟！<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBall</span>(<span class="params">self, grid</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">row, col</span>):</span><br><span class="line">            <span class="keyword">if</span> row == m :</span><br><span class="line">                <span class="keyword">return</span> col</span><br><span class="line">            <span class="keyword">if</span> grid[row][col] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> col == n - <span class="number">1</span> <span class="keyword">or</span> grid[row][col + <span class="number">1</span>] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> grid[row][col + <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> DFS(row + <span class="number">1</span>, col + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> grid[row][col] == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> col == <span class="number">0</span> <span class="keyword">or</span> grid[row][col - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> grid[row][col - <span class="number">1</span>] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> DFS(row + <span class="number">1</span>, col - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [DFS(<span class="number">0</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br></pre></td></tr></table></figure></p>
<p>官解更简洁一些：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBall</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        ans = [-<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            col = j  <span class="comment"># 球的初始列</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> grid:</span><br><span class="line">                <span class="built_in">dir</span> = row[col]</span><br><span class="line">                col += <span class="built_in">dir</span>  <span class="comment"># 移动球</span></span><br><span class="line">                <span class="keyword">if</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col == n <span class="keyword">or</span> row[col] != <span class="built_in">dir</span>:  <span class="comment"># 到达侧边或 V 形</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 成功到达底部</span></span><br><span class="line">                ans[j] = col</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/where-will-the-ball-fall/solution/qiu-hui-luo-he-chu-by-leetcode-solution-xqop/</span></span><br><span class="line"><span class="comment"># 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"># 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Leetcode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop-HDFS</title>
    <url>/2022/04/16/Hadoop-HDFS/</url>
    <content><![CDATA[<h3 id="HDFS-的-Shell-操作"><a href="#HDFS-的-Shell-操作" class="headerlink" title="HDFS 的 Shell 操作"></a>HDFS 的 Shell 操作</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p><code>hadoop fs ...</code>，或 <code>hdfs dfs ...</code>。<br>后面的命令用法和Linux命令操作用法基本差不多。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hadoop fs -mkdir 文件名</code></td>
<td>创建文件夹</td>
<td><code>hadoop fs -mkdir /xiyou/bajie</code></td>
<td>创建<code>/xiyou/bajie</code>的文件夹</td>
</tr>
<tr>
<td><code>hadoop fs -moveFromLocal</code></td>
<td>剪切本地文件上传倒hdfs流经</td>
<td><code>hadoop fs -moveFromLocal a.txt /xiyou</code></td>
<td>将本地的a.txt剪切掉，上传到<code>/xiyou</code>目录下</td>
</tr>
<tr>
<td><code>hadoop fs -copyFromLocal</code></td>
<td>拷贝本地文件上传倒hdfs流经</td>
<td><code>hadoop fs -copyFromLocal b.txt /xiyou</code></td>
<td>将本地的b.txt上传到<code>/xiyou</code>目录下，本地文件还在</td>
</tr>
<tr>
<td><code>hadoop fs -put</code></td>
<td>同<code>-copyFromLocal</code></td>
<td><code>hadoop fs -put wukong.txt /xiyou</code></td>
<td>将本地的wukong.txt上传到<code>/xiyou</code>目录下，本地文件还在</td>
</tr>
<tr>
<td><code>hadoop fs -appendToFile</code></td>
<td>追加一个文件到已经存在的文件末尾</td>
<td><code>hadoop fs -appendToFile jingubnag.txt /xiyou/wukong.txt</code></td>
<td>将jingubang.txt里的内容追加到wukong.txt末尾</td>
</tr>
<tr>
<td><code>hadoop fs -copyToLocal</code></td>
<td>从HDFS拷贝到本地</td>
<td><code>hadoop fs -copyToLocal /xiyou/a.txt  ./</code></td>
<td>把a.txt下载到本地</td>
</tr>
<tr>
<td><code>hadoop fs -get</code></td>
<td>同<code>-CopyToLocal</code></td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
</div>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ol>
<li>-ls: 显示目录信息</li>
<li>-cat：显示文件内容</li>
<li>-chgrp、-chmod、-chown：Linux文件系统中的用法一样，修改文件所属权限</li>
<li>-cp：从HDFS的一个路径拷贝到HDFS的另一个路径</li>
<li>-mv：在HDFS目录中移动文件</li>
<li>-tail：显示一个文件的末尾1kb的数据、</li>
<li>-rm：删除文件或文件夹</li>
<li>-rm -r：递归删除目录及目录里面内容</li>
<li>-du统计文件夹的大小信息</li>
<li>-setrep：设置HDFS中文件的副本数量</li>
</ol>
<h3 id="HDFS-的-API-操作"><a href="#HDFS-的-API-操作" class="headerlink" title="HDFS  的 API 操作"></a>HDFS  的 API 操作</h3><h4 id="Maven-和-idea-的安装与配置"><a href="#Maven-和-idea-的安装与配置" class="headerlink" title="Maven 和 idea 的安装与配置"></a>Maven 和 idea 的安装与配置</h4><ol>
<li>下载maven，防灾一个没有中文没有空格的路径下；</li>
<li>配置maven环境变量；</li>
<li>修改本地仓库路径和镜像（要进入setting.xml去修改！！）；</li>
<li>安装idea，并修改maven配置，在<code>File-New Projects Setup-Settings for New Projects...</code>里进行全局修改。</li>
</ol>
<h4 id="客户端代码操作常用套路"><a href="#客户端代码操作常用套路" class="headerlink" title="客户端代码操作常用套路"></a>客户端代码操作常用套路</h4><ol>
<li>获取客户端对象</li>
<li>执行操作命令</li>
<li>关闭资源</li>
</ol>
<h4 id="以创建文件夹为例"><a href="#以创建文件夹为例" class="headerlink" title="以创建文件夹为例"></a>以创建文件夹为例</h4><ol>
<li>先创建一个maven项目；</li>
<li>添加相关依赖坐标：<dependencies>
    <dependency>
        <groupId>org.apache.hadoop</groupId>
        <artifactId>hadoop-client</artifactId>
        <version>3.1.3</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-log4j12</artifactId>
        <version>1.7.30</version>
    </dependency>
</dependencies></li>
<li>日志添加。在项目的src/main/resources目录下，新建一个文件，命名为“log4j.properties”，在文件中填入<br>log4j.rootLogger=INFO, stdout<br>log4j.appender.stdout=org.apache.log4j.ConsoleAppender<br>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout<br>log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n<br>log4j.appender.logfile=org.apache.log4j.FileAppender<br>log4j.appender.logfile.File=target/spring.log<br>log4j.appender.logfile.layout=org.apache.log4j.PatternLayout<br>log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</li>
<li>在 <code>/src/man/java</code>下创建一个 com.shengrihui.hdfs  包；</li>
<li>创建 HDFSC列宁他 文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shengrihui.hdfs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码操作常用套路</span></span><br><span class="line"><span class="comment"> * 1.获取客户端对象</span></span><br><span class="line"><span class="comment"> * 2.执行操作命令</span></span><br><span class="line"><span class="comment"> * 3.关闭资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HdfsClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FileSystem fs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 链接集群的nn地址</span></span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URI</span>(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个配置文件</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="comment">// 用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;shengrihui&quot;</span>;</span><br><span class="line">        <span class="comment">// 1.获取到了客户端对象</span></span><br><span class="line">        fs = FileSystem.get(uri, configuration, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fs.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMkdirs</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException, IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建一个文件夹</span></span><br><span class="line">        fs.mkdirs(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/xiyou/wukong&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>close()</code>,<code>init()</code>是为了封装代码。<br>运行后结果：<br><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220412/创建文件夹.4ytaphns1eo0.webp" alt="创建文件夹"></p>
<h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPut</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数：</span></span><br><span class="line"><span class="comment">     * 参数1：是否删除源文件</span></span><br><span class="line"><span class="comment">     * 参数2：是否覆盖目标文件（如果已经有了）</span></span><br><span class="line"><span class="comment">     * 参数3：源数据路径</span></span><br><span class="line"><span class="comment">     * 参数4：目的地路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fs.copyFromLocalFile(<span class="literal">false</span>, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;E:\\CS\\BigData\\hadoop\\笔记（word版本）\\笔记（word版本）&quot;</span>), <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220412/上传代码运行结果.78jw6wcrta80.webp" alt="上传代码运行结果"><br><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220412/上传结果.2b5iohrzlv8k.webp" alt="上传结果"></p>
<h5 id="参数优先级"><a href="#参数优先级" class="headerlink" title="参数优先级"></a>参数优先级</h5><p>参数优先级排序：<br>（1）客户端代码中设置的值 &gt;<br>    在<code>init</code>里<code>configuration.set(&quot;dfs.replication&quot;,&quot;3&quot;);</code><br>（2）ClassPath下的用户自定义配置文件 &gt;<br>    在resource目录下新建文件hdfs-site.xml，写入内容；<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">	&lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><br>（3）然后是服务器的自义配置（xxx-site.xml） &gt;<br>（4）服务器的默认配置（xxx-default.xml）</p>
<h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件下载</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数1：源文件是否删除；参数2：源文件的路径（hdfs路径）；参数3：目标地址路径（Windows）</span></span><br><span class="line"><span class="comment">     * 参数4：是否文件校验，从hdfs下载来的数据可能会丢一些数据或错误，会带一个crc的校验码，</span></span><br><span class="line"><span class="comment">     * 再用crc算法算一个值，如果算出来的crc和传过来crc一样，就说明传来的一样</span></span><br><span class="line"><span class="comment">     * false是进行校验，一般不用这个参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fs.copyToLocalFile(<span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://hadoop102/xiyouji&quot;</span>), <span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;E:\\&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：略</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRm</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//参数1：要删除的路径；参数2：是否递归删除</span></span><br><span class="line">    <span class="comment">//删除文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除空目录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除非空目录（必须递归）</span></span><br><span class="line">    <span class="comment">//fs.delete(new Path(&quot;hdfs://hadoop102/jinguo&quot;), true);</span></span><br><span class="line">    fs.delete(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;hdfs://hadoop102/xiyou&quot;</span>),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：略</p>
<h4 id="文件的更名和移动"><a href="#文件的更名和移动" class="headerlink" title="文件的更名和移动"></a>文件的更名和移动</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件的更名和移动</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testmv</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//参数解读：参数1，原文件路径；参数2，目标文件路径</span></span><br><span class="line">        <span class="comment">//文件名称修改</span></span><br><span class="line">        <span class="comment">//fs.rename(new Path(&quot;hdfs://hadoop102/笔记（word版本）&quot;),new Path(&quot;hdfs://hadoop102/note&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件更名移动</span></span><br><span class="line">        <span class="comment">//fs.rename(new Path(&quot;/wcinput/word.txt&quot;),new Path(&quot;/sanguo/a.txt&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//目录更名</span></span><br><span class="line">        fs.rename(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/sanguo&quot;</span>),<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/shuihu&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取文件详细信息"><a href="#获取文件详细信息" class="headerlink" title="获取文件详细信息"></a>获取文件详细信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文件详细信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileDetail</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取所有文件信息</span></span><br><span class="line">    RemoteIterator&lt;LocatedFileStatus&gt; listFiles = fs.listFiles(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/&quot;</span>), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历文件</span></span><br><span class="line">    <span class="keyword">while</span> (listFiles.hasNext()) &#123;</span><br><span class="line">        <span class="type">LocatedFileStatus</span> <span class="variable">fileStatus</span> <span class="operator">=</span> listFiles.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======&quot;</span> + fileStatus.getPath() + <span class="string">&quot;=======&quot;</span>);</span><br><span class="line">        System.out.println(fileStatus.getPermission());<span class="comment">// 权限</span></span><br><span class="line">        System.out.println(fileStatus.getOwner());</span><br><span class="line">        System.out.println(fileStatus.getGroup());</span><br><span class="line">        System.out.println(fileStatus.getLen());</span><br><span class="line">        System.out.println(fileStatus.getModificationTime());<span class="comment">// 上次修改的时间</span></span><br><span class="line">        System.out.println(fileStatus.getReplication());</span><br><span class="line">        System.out.println(fileStatus.getBlockSize());</span><br><span class="line">        System.out.println(fileStatus.getPath().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取块信息</span></span><br><span class="line">        BlockLocation[] blockLocations = fileStatus.getBlockLocations();</span><br><span class="line">        System.out.println(Arrays.toString(blockLocations));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220412/hdfs获取文件信息.3qy8actzeaw0.webp" alt="hdfs获取文件信息"><br>其中，大文件会按快大小128M分成好几个块；<br><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220412/hdfs大文件块信息.2cxiqknp7jvo.webp" alt="hdfs大文件块信息"></p>
<h4 id="判断是文件夹还是文件"><a href="#判断是文件夹还是文件" class="headerlink" title="判断是文件夹还是文件"></a>判断是文件夹还是文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是文件夹还是文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    FileStatus[] listStatus = fs.listStatus(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;/&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (FileStatus status : listStatus) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件 &quot;</span> + status.getPath().getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目录 &quot;</span> + status.getPath().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HDFS读写流程"><a href="#HDFS读写流程" class="headerlink" title="HDFS读写流程"></a>HDFS读写流程</h3><h4 id="HDFS-写流程"><a href="#HDFS-写流程" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h4><p><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220416/HDFS读写流程-总2.7ieye7u3oek0.webp" alt="HDFS读写流程-总"><br>（1）客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已存在，父目录是否存在。<br>    还有是否有权限上传<br>（2）NameNode返回是否可以上传。<br>（3）客户端请求第一个 Block上传到哪几个DataNode服务器上。<br>（4）NameNode返回3个DataNode节点，分别为dn1、dn2、dn3。<br>    节点的选择涉及到节点距离最近、负载均衡（如果多个客户端都在写，那就pass这个节点）<br>（5）客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。<br>（6）dn1、dn2、dn3逐级应答客户端。<br>（7）客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。<br>（8）当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。<br>    为什么不是多个节点同时连接客户端？防止因为有任何一个节点没有完成而一直在等；<br>    到dn1的时候同时就往后倒dn2；<br>    最小单位是516字节（4个校验位），攒倒64kB的packet发送；<br>    ACK队列，接受下一端是否接受成功，用于备份。</p>
<h5 id="网络拓扑-节点距离计算"><a href="#网络拓扑-节点距离计算" class="headerlink" title="网络拓扑-节点距离计算"></a>网络拓扑-节点距离计算</h5><p>节点距离：两个节点到达最近的共同祖先的距离总和。<br><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220416/HDFS读写数据-节点距离.137zn4lyrwa8.webp" alt="HDFS读写数据-节点距离"></p>
<h5 id="机架感知（副本存储节点选择）"><a href="#机架感知（副本存储节点选择）" class="headerlink" title="机架感知（副本存储节点选择）"></a>机架感知（副本存储节点选择）</h5><p><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220416/HDFS读写流程-机架感知.8o1r32pms5s.webp" alt="HDFS读写流程-机架感知"><br>第一个副本：本地（如果客户端不在集群，随机算一个）<br>    本地是为了上传的速度<br>第二个副本：另一个机架里随机<br>    另一个机架是为了数据的可靠性<br>第三个副本：和第二个同一个机架随机<br>    兼顾可靠性和速度</p>
<h4 id="HDFS读数据流程"><a href="#HDFS读数据流程" class="headerlink" title="HDFS读数据流程"></a>HDFS读数据流程</h4><p><img src="https://cdn.jsdelivr.net/gh/shengrihui/Image-hosting@master/20220416/HDFS读写流程-读数据.5k5bef6075s0.webp" alt="HDFS读写流程-读数据"><br>（1）客户端通过DistributedFileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。<br>（2）挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据。<br>    节点距离最近，也考虑负载<br>（3）DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。<br>（4）客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。<br>    串行读，先读第一块，再读第二块</p>
]]></content>
      <categories>
        <category>大数据Hadoop</category>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
</search>
