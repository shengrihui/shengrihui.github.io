<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode_345. 反转字符串中的元音字母</title>
    <url>/2021/08/19/Leetcode-345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>345. 反转字符串中的元音字母<br>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：”hello”<br>输出：”holle”<br>示例 2：</p>
<p>输入：”leetcode”<br>输出：”leotcede”</p>
<p>提示：</p>
<p>元音字母不包含字母 “y” 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">https://leetcode-cn.com/problems/reverse-vowels-of-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p>这提不难。<br>弄两个指针<code>i</code>和<code>j</code>，<code>i</code>从前往后走，<code>j</code>从后往前走，当遇到原因字母的时候，就停下来。当两个指针都停下来的时候，交换两个字母。使用<code>while</code>循环，退出条件是<code>i</code>和<code>j</code>重合。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>python<pre><code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def reverseVowels(s):</span><br><span class="line">l = list(s)</span><br><span class="line">i, j = 0, len(s)-1</span><br><span class="line">Vowels = [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;A&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;U&#x27;]</span><br><span class="line"># vowels = &quot;aeiouAEIOU&quot;</span><br><span class="line">i_step = 1</span><br><span class="line">j_step = -1</span><br><span class="line">while i &lt; j:</span><br><span class="line">    if l[i] in Vowels:</span><br><span class="line">        i_step = 0</span><br><span class="line">    if l[j] in Vowels:</span><br><span class="line">        j_step = 0</span><br><span class="line"></span><br><span class="line">    if i_step == j_step == 0:</span><br><span class="line">        l[i], l[j] = l[j], l[i]</span><br><span class="line">        i_step = 1</span><br><span class="line">        j_step = -1</span><br><span class="line">    i += i_step</span><br><span class="line">    j += j_step</span><br><span class="line">return &#x27;&#x27;.join(l)</span><br></pre></td></tr></table></figure>
</code></pre>
  和官方题解几乎一样。</li>
<li>C<pre><code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   	<span class="function"><span class="keyword">int</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> vowels[] = <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vowels[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == vowels[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseVowels</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> i_step = <span class="number">1</span>, j_step = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> == isVowel(s[i]))</span><br><span class="line">			i_step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> == isVowel(s[j]))</span><br><span class="line">			j_step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i_step == <span class="number">0</span> &amp;&amp; j_step == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c %c %s\n&quot;</span>, s[i], s[j], s);</span><br><span class="line">			tmp = s[i];</span><br><span class="line">			s[i] = s[j];</span><br><span class="line">			s[j] = tmp;</span><br><span class="line">			i_step = <span class="number">1</span>;</span><br><span class="line">			j_step = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i += i_step;</span><br><span class="line">		j += j_step;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fHEmKP"><img src="https://z3.ax1x.com/2021/08/19/fHEmKP.jpg" alt="python提交记录"></a><br><a href="https://imgtu.com/i/fHEZvt"><img src="https://z3.ax1x.com/2021/08/19/fHEZvt.jpg" alt="C语言提交记录"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_526. 优美的排列</title>
    <url>/2021/08/18/Leetcode-526-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>526. 优美的排列<br>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p>
<p>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？</p>
<p>示例1:</p>
<p>输入: 2<br>输出: 2<br>解释: </p>
<p>第 1 个优美的排列是 [1, 2]:<br>  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</p>
<p>第 2 个优美的排列是 [2, 1]:<br>  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除<br>说明:</p>
<p>N 是一个正整数，并且不会超过15。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/beautiful-arrangement">https://leetcode-cn.com/problems/beautiful-arrangement</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法零：流氓方法"><a href="#方法零：流氓方法" class="headerlink" title="方法零：流氓方法"></a>方法零：流氓方法</h3><p>因为题目说明了N不会超过15，那就用例测试所有的数得到答案，然后用列表或者一串<code>if</code>语句就可以通过了。</p>
<h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>本来就隐约觉得会用到回溯算法，但还是想先用排列组合的方法试一下，但太太困难了，最后还是用了回溯算法。<br>先创建一个字典<code>d</code>，可以理解成键是第几个位置，对应的值是该位置上能放哪些数。<br>接下来是回溯函数，设置两个参数，第一个是用于记录当前状态的列表，第二个是 现在要填的是哪一个位置<code>pos</code>，返回当前状态下的优美排列数<code>c</code>。<br><code>c</code>初始设为0，<code>i</code>遍历可以在<code>pos</code>位置上的所有数，即<code>d[pos]</code>，如果<code>i</code>不在列表之内，就将它填到列表的对应位置上，并<code>c += func(s, pos+1)</code>，递归到下一个<code>pos</code>中，直到<code>pos==n</code>时，<code>c += 1</code>。<br>可能还是直接看代码清楚一些吧。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def countArrangement(n):</span><br><span class="line">    d = defaultdict(list)</span><br><span class="line">    # 第num个位置上可以放哪些数</span><br><span class="line">    for num in range(1, n+1):</span><br><span class="line">        for i in range(1, num+1):</span><br><span class="line">            if num % i == 0:</span><br><span class="line">                d[num].append(i)</span><br><span class="line">                if num != i:</span><br><span class="line">                    d[i].append(num)</span><br><span class="line"></span><br><span class="line">    def func(s, pos):</span><br><span class="line">        c = 0</span><br><span class="line">        for i in d[pos]:</span><br><span class="line">            if i not in s:</span><br><span class="line">                s[pos-1] = i</span><br><span class="line">                if pos == n:</span><br><span class="line">                    c += 1</span><br><span class="line">                else:</span><br><span class="line">                    c += func(s, pos+1)</span><br><span class="line">                s[pos-1] = 0</span><br><span class="line">        return c</span><br><span class="line">    return func([0]*n, 1)</span><br></pre></td></tr></table></figure>
<p>官方的回溯算法和我写得几乎一样，只是他用的是集合。我一开始也是想用集合的，但不知道集合的<code>disturb</code>方法，才改成了列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countArrangement(self, n: int) -&gt; int:</span><br><span class="line">        match = defaultdict(list)</span><br><span class="line">        for i in range(1, n + 1):</span><br><span class="line">            for j in range(1, n + 1):</span><br><span class="line">                if i % j == 0 or j % i == 0:</span><br><span class="line">                    match[i].append(j)</span><br><span class="line">        </span><br><span class="line">        num = 0</span><br><span class="line">        vis = set()</span><br><span class="line"></span><br><span class="line">        def backtrack(index: int) -&gt; None:</span><br><span class="line">            if index == n + 1:</span><br><span class="line">                nonlocal num</span><br><span class="line">                num += 1</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            for x in match[index]:</span><br><span class="line">                if x not in vis:</span><br><span class="line">                    vis.add(x)</span><br><span class="line">                    backtrack(index + 1)</span><br><span class="line">                    vis.discard(x)</span><br><span class="line">                   </span><br><span class="line">        backtrack(1)</span><br><span class="line">        return num</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/beautiful-arrangement/solution/you-mei-de-pai-lie-by-leetcode-solution-vea2/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="方法二：状态压缩-动态规划"><a href="#方法二：状态压缩-动态规划" class="headerlink" title="方法二：状态压缩+动态规划"></a>方法二：状态压缩+动态规划</h3><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>这个方法实在难理解，借助官方题解下的评论才勉强看懂。也不知道什么叫状态压缩。<br>首先，是动态规划的状态表示。这里用二进制数表示，从右往左数，第<code>i</code>位上的数字是1，就表示<code>i</code>这个数字被选取了。创建长度为<code>1&lt;&lt;n</code>的数组<code>f</code>，表示某一状态下的优美排列数。<br>以<code>n=6</code>举例。<code>f[000110]</code>的意思是（这里下标里的数都是二进制数）：数字2和3能够组成的优美排列数。<br>所以，最后返回的结果就是<code>f[1&lt;&lt;n -1]</code>，即<code>f[111111]</code>。<br>然后是转移方程。<code>f[111111] = f[011111] + f[101111] + f[110111] + f[111011] + f[111101] + f[111110]</code>，也就是说，要算取了6个数的优美排列，就算上所有任意去掉这已经取了的6个数中的一个的状态的优美排列数。当然，事实上并不是所有的数都要相加，因为还需要判断，去掉的那个数能否放在第6个位置上。比如<code>f[101111]</code>这时数字<code>5</code>还没有取，而<code>5</code>并不能放在第6个位置上。<br>再举个例子。<code>f[100110]</code>是要算数字<code>2</code>、<code>3</code>和<code>6</code>这3个数的优美排列，那就看哪个数可以放在第3个位置上，这里<code>6</code>和<code>3</code>可以放在第3个位置上，而这时候已经取了的数字分别是<code>2</code>、<code>3</code>和<code>2</code>、<code>6</code>所以<code>f[100110] = f[000110] + f[100010]</code>。<br>因此，设计双重循环，外层<code>mask</code>循环遍历所有状态，内存<code>i</code>循环做的事情是从0（最右边）开始遍历<code>mask</code>的每一位，如果第<code>i+1</code>位上是<code>1</code>，并且这个<code>1</code>对应的数<code>i+1</code>能放在这个位置上（这句话的意思是：假装还没有取<code>i+1</code>这个数，此时已经取了<code>num - 1</code>个数，那 <code>i+1</code>能否放在<code>num</code>这个位置上，所以，<code>num</code>的意思就是要求的<code>mask</code>当中已经取了的数的数量，所以，<code>num</code>可以通过统计<code>mask</code>中有几个<code>1</code>来获得），那么<code>f[mask]</code>就可以加上这种状态下的优美排列数了。<br>还是结合代码进行理解吧。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def countArrangement(n):</span><br><span class="line">    # f[X] X是一个二进制数，</span><br><span class="line">    # 例：f[000110]，表示数字2和3被选取后排在前面的优美排列数</span><br><span class="line">    # 从右往左数，1表示被选</span><br><span class="line">    f = [0]*(1 &lt;&lt; n)</span><br><span class="line">    f[0] = 1</span><br><span class="line"></span><br><span class="line">    # 动态规划，mask 遍历1到 1&lt;&lt;n</span><br><span class="line">    for mask in range(1, 1 &lt;&lt; n):</span><br><span class="line">        # 计mask有多少个1</span><br><span class="line">        # 以100110举例例，mum=3</span><br><span class="line">        # 也就是说，2、3、6被选取了，要放在前三个求他们呢的优美排列数</span><br><span class="line">        # 那需要判断第3个位置（也就是第 num个位置）可以放谁，</span><br><span class="line">        # 这里可以放3和6，</span><br><span class="line">        # 前两个位置是2，6，f[100110] += f[100010]</span><br><span class="line">        # 前两个位置是2，3，f[100110] += f[000110]</span><br><span class="line">        num = bin(mask).count(&quot;1&quot;)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            # mask &amp; (1 &lt;&lt; i  mask的第i+1位是不是1</span><br><span class="line">            # 如果是，</span><br><span class="line">            # i+1这个数能不能放在 num 这个位置上</span><br><span class="line">            # 如果可以，</span><br><span class="line">            # mask ^ (1 &lt;&lt; i) mask的第i+1位改为0</span><br><span class="line">            # f[mask] += f[mask ^ (1 &lt;&lt; i)]</span><br><span class="line">            # 注意i与i+1，i-1的区别含义</span><br><span class="line">            if (mask &amp; (1 &lt;&lt; i) and (num % (i+1) == 0 or (i+1) % num == 0)):</span><br><span class="line">                f[mask] += f[mask ^ (1 &lt;&lt; i)]</span><br><span class="line">        # for i in range(1,n+1):</span><br><span class="line">        #     if (mask &amp; (1 &lt;&lt; (i-1)) and (num % i == 0 or i % num == 0)):</span><br><span class="line">        #         f[mask] += f[mask ^ (1 &lt;&lt; (i-1))]</span><br><span class="line">    return f[(1 &lt;&lt; n)-1]</span><br></pre></td></tr></table></figure>


<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><img src="https://z3.ax1x.com/2021/08/18/fI1buR.jpg" alt="526. 优美的排列提交记录"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_551. 学生出勤记录 I</title>
    <url>/2021/08/17/Leetcode-551-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-I/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>551.-学生出勤记录-I<br>给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<p>‘A’：Absent，缺勤<br>‘L’：Late，迟到<br>‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：</p>
<p>按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>学生 不会 存在 连续 3 天或 3 天以上的迟到（’L’）记录。<br>如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。</p>
<p>示例 1：</p>
<p>输入：s = “PPALLP”<br>输出：true<br>解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。<br>示例 2：</p>
<p>输入：s = “PPALLL”<br>输出：false<br>解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000<br>s[i] 为 ‘A’、’L’ 或 ‘P’</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/student-attendance-record-i">https://leetcode-cn.com/problems/student-attendance-record-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>太简单了，略</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>python<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def checkRecord(self, s: str) -&gt; bool:</span><br><span class="line">        return s.count(&quot;A&quot;)&lt;2 and s.count(&quot;LLL&quot;)&lt;=0</span><br></pre></td></tr></table></figure></li>
<li>C<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> absent = <span class="number">0</span>, late = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*s == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			absent++;</span><br><span class="line">			late = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (absent == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*s == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			late++;</span><br><span class="line">			<span class="keyword">if</span> (late == <span class="number">3</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			late = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/f4KPi9"><img src="https://z3.ax1x.com/2021/08/17/f4KPi9.png" alt="551. 学生出勤记录 I.png"></a><br><a href="https://imgtu.com/i/f4h6TP"><img src="https://z3.ax1x.com/2021/08/17/f4h6TP.jpg" alt="551. 学生出勤记录 IC语言"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_541. 反转字符串 II</title>
    <url>/2021/08/20/Leetcode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>541. 反转字符串 II</p>
<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每 <code>2k</code> 个字符反转前 <code>k</code> 个字符。</p>

<ul>
    <li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
    <li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>s = "abcdefg", k = 2
<strong>输出：</strong>"bacdfeg"
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>s = "abcd", k = 2
<strong>输出：</strong>"bacd"
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
    <li><code>s</code> 仅由小写英文组成</li>
    <li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
</ul>


<h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>难度不大，直接上代码、</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        t = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(t), <span class="number">2</span> * k):</span><br><span class="line">            t[i: i + k] = <span class="built_in">reversed</span>(t[i: i + k])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def reverseStr(self, s: str, k: int) -&gt; str:</span></span><br><span class="line"><span class="comment">#         kk = 2*k</span></span><br><span class="line"><span class="comment">#         n = len(s)</span></span><br><span class="line"><span class="comment">#         i, j = 0, k-1</span></span><br><span class="line"><span class="comment">#         st = list(s)</span></span><br><span class="line"><span class="comment">#         while i &lt; n:</span></span><br><span class="line"><span class="comment">#             start, end = i, j</span></span><br><span class="line"><span class="comment">#             if j &gt;= n:</span></span><br><span class="line"><span class="comment">#                 end = n-1</span></span><br><span class="line"><span class="comment">#             # print(i, j, start, end, n)</span></span><br><span class="line"><span class="comment">#             while start &lt; end:</span></span><br><span class="line"><span class="comment">#                 st[start], st[end] = st[end], st[start]</span></span><br><span class="line"><span class="comment">#                 start += 1</span></span><br><span class="line"><span class="comment">#                 end -= 1</span></span><br><span class="line"><span class="comment">#             i += kk</span></span><br><span class="line"><span class="comment">#             j += kk</span></span><br><span class="line"><span class="comment">#         return &#x27;&#x27;.join(st)</span></span><br></pre></td></tr></table></figure>
<p>注释掉的是我的，没注释掉的是官方的。可见对python的有些东西还是不熟悉。</p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fOVZSe"><img src="https://z3.ax1x.com/2021/08/20/fOVZSe.jpg" alt="通过.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_552. 学生出勤记录 II</title>
    <url>/2021/08/19/Leetcode-552-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-II/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>552. 学生出勤记录 II<br>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<ul>
    <li><code>'A'</code>：Absent，缺勤</li>
    <li><code>'L'</code>：Late，迟到</li>
    <li><code>'P'</code>：Present，到场</li>
</ul>

<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>

<ul>
    <li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>
    <li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>
</ul>

<p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>8
<strong>解释：
</strong>有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>3
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 10101
<strong>输出：</strong>183236316
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>



<h3 id="方法一和方法二：我的动态规划-排列组合（-泰波纳契数列）"><a href="#方法一和方法二：我的动态规划-排列组合（-泰波纳契数列）" class="headerlink" title="方法一和方法二：我的动态规划+排列组合（+泰波纳契数列）"></a>方法一和方法二：我的动态规划+排列组合（+泰波纳契数列）</h3><p>因为A的情况只有两种：一种是没有A，一种是有A，所以分开考虑。而有A的情况下，A只能有一个，所以考虑将这一个A分别放在字符串的所有位置，这样就将整个字符串分成了左右两个没有A的小部分。若用<code>dp[i]</code>记只有p和L组成的长度为<code>i</code>的字符串当中数量，那么带上A的总数就是将A放在每个位置上的时候<code>dp[A左边长度]*dp[A右边的长度]</code>的总和。而最前面考虑的整个字符串当中没有A的情况即为<code>dp[总长度]</code>。<br>所以接下来就是<code>dp[i]</code>的状态转移方程了。这里再建立两个状态，<code>present[i]</code>和<code>late[i]</code>，分别用于表示长度为<code>i</code>时候以P和L开头（或结尾，其实一样的）的符合条件的数量。于是有状态转移方程：</p>
<ul>
<li><code>present[i] = present[i-1]+late[i-1]</code><br> 因为P可以既可以接在P后边，也可以接在L后边。 </li>
<li><code>late[i] = present[i-1]+present[i-2]</code><br> 因为L可以接在两种情况后边：①恨着P；②只有一个L，这种时候就需要隔着一位是P了。</li>
<li><code>dp[i] = present[i]+late[i]</code><br>这样就可以写代码了。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    dp, late, present = [<span class="number">0</span>]*(n+<span class="number">1</span>), [<span class="number">0</span>]*(n+<span class="number">1</span>), [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># dp, late, present = &#123;&#125;, &#123;&#125;, &#123;&#125;</span></span><br><span class="line">    present[<span class="number">0</span>] = late[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    present[<span class="number">1</span>] = late[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    present[<span class="number">2</span>] = late[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        present[i] = present[i-<span class="number">1</span>]+late[i-<span class="number">1</span>]</span><br><span class="line">        late[i] = present[i-<span class="number">1</span>]+present[i-<span class="number">2</span>]</span><br><span class="line">        dp[i] = (present[i]+late[i]) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">    <span class="comment"># print(present)</span></span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        t = dp[i]*dp[n-<span class="number">1</span>-i]</span><br><span class="line">        ret += t % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">    ret += dp[n]</span><br><span class="line">    <span class="keyword">return</span> ret % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
初始状态可以人工算出。<br>我以为我的思路那么简单清晰易懂，肯定没有问题（虽然确实可以解），但是提交之后超出时间限制了！以为因为中间没有每一步都取模（刚开始的时候没有）会导致大数运算变慢，于是每一步都加上取模运算；以为因为是列表取值慢于是有改成字典；以为网断了（其实并没有），重新连了网——而这些都没有用！<br>后来觉得可能是循环里头<code>[]</code>的取值操作有点多，于是将状态转移方程展开往下写，发现这里竟然有个泰波纳契数列。<br>dp[i]<br>= present[i]+late[i]<br>=present[i-1]+late[i-1]+present[i-1]+present[i-2]<br>=present[i-1]+(present[i-2]+present[i-3]) + present[i-1]+present[i-2]<br>=2<em>present[i-1]+2</em>present[i-2]+present[i-3]<br>于是“改进”了方法的前面部分。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkRecord2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">19</span></span><br><span class="line">    <span class="comment"># dp = [0]*(n+1)</span></span><br><span class="line">    dp = &#123;&#125;</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>], dp[<span class="number">3</span>] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, n+<span class="number">1</span>):</span><br><span class="line">        dp[i] = a+<span class="number">2</span>*b+<span class="number">2</span>*c</span><br><span class="line">        a, b, c = b, c, a+b+c</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
然而仍然超时。——事实上这种更用时，后面放性能分析。<br><a href="https://imgtu.com/i/fq7VpQ"><img src="https://z3.ax1x.com/2021/08/19/fq7VpQ.jpg" alt="超出时间限制.jpg"></a></li>
</ul>
<h3 id="方法三和方法四：官方的动态规划和我照官方的动态规划"><a href="#方法三和方法四：官方的动态规划和我照官方的动态规划" class="headerlink" title="方法三和方法四：官方的动态规划和我照官方的动态规划"></a>方法三和方法四：官方的动态规划和我照官方的动态规划</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkRecord</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># 长度，A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp = [[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - <span class="number">1</span>][j][k]) % MOD</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][k]) % MOD</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>]) % MOD</span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                total += dp[n][j][k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total % MOD</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/student-attendance-record-ii/solution/xue-sheng-chu-qin-ji-lu-ii-by-leetcode-s-kdlm/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>借助他前面的讲解，也并没有很看懂，但了解了大概意思，然后理解着自己写了一个。<br>代码前面部分意思是列举所有情况，开头数字是dp下标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkRecord5</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 0 前面没有A，现在要加P  +=[0]+[1]+[2]</span></span><br><span class="line">    <span class="comment"># 1 前面没有A，上一个不是L，现在要加L  +=[0]</span></span><br><span class="line">    <span class="comment"># 2 前面没有A，上一个是L，现在要加L    +=[1]</span></span><br><span class="line">    <span class="comment"># 3 前面有A，现在要加P   +=[6]+[3]+[4]+[5]</span></span><br><span class="line">    <span class="comment"># 4 前面有A，上一个不是L，现在要加L    +=[6]+[3]</span></span><br><span class="line">    <span class="comment"># 5 前面有A，上一个是L，现在要加L     +=[4]</span></span><br><span class="line">    <span class="comment"># 6 现在要加A  +=[0]+[1]+[2]</span></span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">    <span class="comment"># dp = [[0 for _ in range(7)] for _ in range(n+1)]</span></span><br><span class="line">    <span class="comment"># dp[1] = [1, 1, 0, 0, 0, 0, 1]</span></span><br><span class="line">    <span class="comment"># for i in range(2, n+1):</span></span><br><span class="line">    <span class="comment">#     dp[i][0] += (dp[i-1][0]+dp[i-1][1]+dp[i-1][2])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][1] += dp[i-1][0]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][2] += dp[i-1][1]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][3] += (dp[i-1][6]+dp[i-1][3]+dp[i-1][4]+dp[i-1][5])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][4] += (dp[i-1][6]+dp[i-1][3])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][5] += dp[i-1][4]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][6] += (dp[i-1][0]+dp[i-1][1]+dp[i-1][2])% MOD</span></span><br><span class="line">    <span class="comment"># return sum(dp[n])%MOD</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)], [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)]]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        a, b = i % <span class="number">2</span>, <span class="number">1</span>-i % <span class="number">2</span></span><br><span class="line">        dp[a][<span class="number">0</span>] += (dp[b][<span class="number">0</span>]+dp[b][<span class="number">1</span>]+dp[b][<span class="number">2</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">1</span>] += dp[b][<span class="number">0</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">2</span>] += dp[b][<span class="number">1</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">3</span>] += (dp[b][<span class="number">6</span>]+dp[b][<span class="number">3</span>]+dp[b][<span class="number">4</span>]+dp[b][<span class="number">5</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">4</span>] += (dp[b][<span class="number">6</span>]+dp[b][<span class="number">3</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">5</span>] += dp[b][<span class="number">4</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">6</span>] += (dp[b][<span class="number">0</span>]+dp[b][<span class="number">1</span>]+dp[b][<span class="number">2</span>]) % MOD</span><br><span class="line">        dp[b] = [<span class="number">0</span>]*<span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp[n % <span class="number">2</span>]) % MOD</span><br></pre></td></tr></table></figure>
<p>这里其实也有两个方法，没注释掉的用上了滚动数组，这里需要注意的是清零的这一步<code>dp[b] = [0]*7</code>操作不能忘了。</p>
<h3 id="方法五：-矩阵快速幂"><a href="#方法五：-矩阵快速幂" class="headerlink" title="方法五： 矩阵快速幂"></a>方法五： 矩阵快速幂</h3><p>有我前面列举过所有情况的基础上，写出矩阵快速幂就并不是那么难了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkRecord6</span>(<span class="params">n</span>):</span></span><br><span class="line">    mat = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    ]</span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="comment"># a[r*m] * b[m*c] = ret[r*c]</span></span><br><span class="line">        r, m, c = <span class="built_in">len</span>(a), <span class="built_in">len</span>(a[<span class="number">0</span>]), <span class="built_in">len</span>(b[<span class="number">0</span>])</span><br><span class="line">        ret = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(c)]<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(r)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    ret[i][j] += a[i][k]*b[k][j]</span><br><span class="line">                    ret[i][j] %= MOD</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixpow</span>(<span class="params">mat, n</span>):</span></span><br><span class="line">        ret = [[<span class="number">1</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ret = multiply(mat, ret)</span><br><span class="line">            mat = multiply(mat, mat)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    ret = matrixpow(mat, n)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">        ans += i[<span class="number">0</span>] % MOD</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><h5 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h5><ul>
<li>动态规划通过<br> <a href="https://imgtu.com/i/fqXhEn"><img src="https://z3.ax1x.com/2021/08/19/fqXhEn.jpg" alt="动态规划通过.jpg"></a></li>
<li>矩阵快速幂（官方）<br> <a href="https://imgtu.com/i/fqXjER"><img src="https://z3.ax1x.com/2021/08/19/fqXjER.jpg" alt="矩阵快速幂（官方）.jpg"></a></li>
<li>矩阵快速幂（自己）<br> <a href="https://imgtu.com/i/fqjVUI"><img src="https://z3.ax1x.com/2021/08/19/fqjVUI.jpg" alt="矩阵快速幂（自己）.jpg"></a></li>
</ul>
</li>
<li><h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5> 用<code>test = [3, 4, 5, 6, 7, 10101, 100000]</code>分别作为输入，用spyder进行性能分析。<br> <a href="https://imgtu.com/i/fqjXQS"><img src="https://z3.ax1x.com/2021/08/19/fqjXQS.jpg" alt="性能分析.jpg"></a><br> 1、2、3、5分别对应前面的方法一、二、三、四。可见泰波纳契数列的”改进“是个灾难啊。6、7分别对应自己和官方的矩阵快速幂。</li>
<li><h5 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h5> 1.真难！不是题目本身，因为虽然是一道困难提，但我还是比较快地有了方法 ，并且能够正确求解，但是总是超时而不清楚原因再哪实在崩溃！<br> 2.<code>1 &lt;= n &lt;= 10<sup>5</sup></code>，10<sup>5</sup>大约是273多年。</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>快速幂/矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode题解</title>
    <url>/2021/08/17/Leetcode%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>因为既想在Github上传题解思路和代码，又想在博客上传，但保证两边同步好麻烦，所以这里列一个列表，链接到Github上。</p>
<h3 id="301-400"><a href="#301-400" class="headerlink" title="301-400"></a>301-400</h3><ul>
<li><a href="https://github.com/shengrihui/Leetcode/blob/c396f399bcca39c40923411eabf0306c7d89739f/3/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.md">345. 反转字符串中的元音字母</a><h3 id="501-600"><a href="#501-600" class="headerlink" title="501~600"></a>501~600</h3></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/5acbc6232b0a90c9cf3beaaa4972ba3e9174d7ab/5/526.%20%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/526.%20%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97.md">526.优美的排列</a></li>
<li>[541. 反转字符串 ](<a href="https://github.com/shengrihui/Leetcode/blob/c5b27e27baac035e0fddb3e64867fab88630da82/5/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II.md">https://github.com/shengrihui/Leetcode/blob/c5b27e27baac035e0fddb3e64867fab88630da82/5/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II.md</a></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/96ca3695c85441f9cc189b123944249f5bb81bbc/5/551.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20I/551.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20I_%E9%A2%98%E8%A7%A3.md">551. 学生出勤记录 I_题解</a></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/c396f399bcca39c40923411eabf0306c7d89739f/5/552.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20II/552.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20II.md">552. 学生出勤记录 II</a></li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2021/08/05/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 支持两种形式的标题, [Setext] [1] 和 [atx] [2].<br>Setext 样式的标题使用的等号来表示一级标题, 使用连字符表示二级标题. 例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">&gt;This is an H1</span></span><br><span class="line"><span class="section">=============</span></span><br><span class="line">This is an H2</span><br><span class="line">&gt;-------------</span><br></pre></td></tr></table></figure>

<p>任意长度的 = 或 - 都是可以的.<br>Atx 样式的标题每行开头使用 1-6 井号, 对应 1-6 级标题. 例如:</p>
</blockquote>
<blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure>
<p>可选地, 你可以 “关闭” atx 样式的标题. 这纯粹是美化需要 – 如果你认为这样美观一些就用吧. 关&gt;闭标签的井号数量甚至不需要和起始位置的匹配. (起始的井号数量决定了标题的级别.) :</p>
<h1 id="This-is-an-H1"><a href="#This-is-an-H1" class="headerlink" title="This is an H1"></a>This is an H1</h1><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2"></a>This is an H2</h2><h3 id="This-is-an-H3"><a href="#This-is-an-H3" class="headerlink" title="This is an H3"></a>This is an H3</h3></blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题 ##</span></span><br><span class="line"><span class="section">这也是一级标题</span></span><br><span class="line"><span class="section">=========</span></span><br><span class="line"><span class="section">这是二级标题</span></span><br><span class="line"><span class="section">-------</span></span><br></pre></td></tr></table></figure>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><blockquote>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h1 id="这也是一级标题"><a href="#这也是一级标题" class="headerlink" title="这也是一级标题"></a>这也是一级标题</h1><h2 id="这是二级标题-1"><a href="#这是二级标题-1" class="headerlink" title="这是二级标题"></a>这是二级标题</h2></blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 使用 email 样式的 &gt; 字符作为块引用. 如果你熟悉 email 消息中的引用段落, 那么你同样可以在 Markdown 中创建块引用. 最好对引用文本采取强制换行并在每一行行首放一个 &gt; :</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span></span><br><span class="line"><span class="quote">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span></span><br><span class="line"><span class="quote">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span></span><br><span class="line"><span class="quote">&gt; id sem consectetuer libero luctus adipiscing.</span></span><br></pre></td></tr></table></figure>
<p>Markdown 中可以简便地只在每一个需要强制换行的段落的首行前面加上一个 &gt; :</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span></span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span></span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>块引用可以嵌套 (例如, 块引用中包含块引用) , 只需添加额外层级的 &gt; 即可:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is the first level of quoting.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; This is nested blockquote.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Back to the first level.</span></span><br></pre></td></tr></table></figure>
<p>块引用可以包含 Markdown 元素, 包括标题, 列表和代码块:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; ## This is a header.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 1.   This is the first list item.</span></span><br><span class="line"><span class="quote">&gt; 2.   This is the second list item.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Here&#x27;s some example code:</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;     return shell<span class="emphasis">_exec(&quot;echo $input | $markdown_</span>script&quot;);</span></span><br><span class="line">&gt;、</span><br></pre></td></tr></table></figure>
<p>任何合适的文本编辑器都应该可以很方便的创建 email 样式的块引用. 例如, 用 BBEdit 就可以选取文本然后从 ‘Text’ 菜单中选择 ‘Increase Quote Level’.</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是一级引用</span><br><span class="line">&gt;&gt;这是二级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;这是好多级引用</span><br></pre></td></tr></table></figure>
<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><blockquote>
<p>这是一级引用</p>
<blockquote>
<p>这是二级引用</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是好多级引用</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="文档-2"><a href="#文档-2" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 支持有序列表和无序列表.</p>
<p>无序列表使用星号, 加号, 和连字符 – 这些符号是可互换的 – 最为列表标记:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Red</span><br><span class="line"><span class="bullet">*</span>   Green</span><br><span class="line"><span class="bullet">*</span>   Blue</span><br></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span>   Red</span><br><span class="line"><span class="bullet">+</span>   Green</span><br><span class="line"><span class="bullet">+</span>   Blue</span><br></pre></td></tr></table></figure>
<p>以及:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span>   Red</span><br><span class="line"><span class="bullet">-</span>   Green</span><br><span class="line"><span class="bullet">-</span>   Blue</span><br></pre></td></tr></table></figure>
<p>有序列表使用数字加句号:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Bird</span><br><span class="line"><span class="bullet">2.</span>  McHale</span><br><span class="line"><span class="bullet">3.</span>  Parish</span><br></pre></td></tr></table></figure>
<p>需要注意的是这里的数字序号对于最终生成 HTML 是没有影响的. 这里 Markdown 输出的 HTML 列表是:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>McHale<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Parish<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即使你把列表写成这样:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Bird</span><br><span class="line"><span class="bullet">1.</span>  McHale</span><br><span class="line"><span class="bullet">1.</span>  Parish</span><br></pre></td></tr></table></figure>
<p>甚至这样:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">3.</span> Bird</span><br><span class="line"><span class="bullet">1.</span> McHale</span><br><span class="line"><span class="bullet">8.</span> Parish</span><br></pre></td></tr></table></figure>
<p>你都讲得到相同的 HTML 输出. 重点是, 如果你希望你的 Markdown 源码中的列表序号匹配输出的 HTML 列表序号, 你应该使用正常的序号 . 当然, 如果你想简单点, 也可不必这么做.</p>
<p>即使你使用错误的列表序号, 最终生成的列表仍然会以序号 1 开始. 在未来的版本里, Markdown 可能支持以任意数字作为列表起始序号.</p>
<p>List 标记通常从左边开始, 可以用三个及以上的空格来缩进. List 标记后面应该跟一个以上的空格或者一个水平制表符.</p>
<p>为了使列表更美观, 可以用悬挂缩进来格式化列表项:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line"><span class="code">    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span></span><br><span class="line"><span class="code">    viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"><span class="code">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span></span><br><span class="line"><span class="code">    Suspendisse id sem consectetuer libero luctus adipiscing.</span></span><br><span class="line"><span class="code">    但是这不是必须的:</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span>   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"><span class="bullet">*</span>   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>如果列表项中包含空行, Markdown 会在 HTML 输出中用 </p><p> 来包裹他们. 例如, 下面的输入:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Bird</span><br><span class="line"><span class="bullet">*</span>   Magic</span><br></pre></td></tr></table></figure>
<p>会输出:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Magic<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Bird</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   Magic</span><br></pre></td></tr></table></figure>
<p>会输出:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Magic<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>列表项可能包含多个段落. 列表项中的每个段落都必须用 4 个空格或一个水平制表符来缩进:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line"><span class="code">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span></span><br><span class="line"><span class="code">    mi posuere lectus.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span></span><br><span class="line"><span class="code">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span></span><br><span class="line"><span class="code">    sit amet velit.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span>  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>同上, 悬挂缩进只是为了更美观, 而非强制要求:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line"><span class="code">    This is the second paragraph in the list item. You&#x27;re</span></span><br><span class="line"><span class="code">only required to indent the first line. Lorem ipsum dolor</span></span><br><span class="line"><span class="code">sit amet, consectetuer adipiscing elit.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span>   Another item in the same list.</span><br></pre></td></tr></table></figure>
<p>如果列表项中包含块注释 , 块注释标记 &gt; 需要缩进:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line"><span class="code">    &gt; This is a blockquote</span></span><br><span class="line"><span class="code">    &gt; inside a list item.</span></span><br></pre></td></tr></table></figure>
<p>如果列表项中有代码块, 代码块需要 双倍 缩进– 8 个空格或者两个水平制表符:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> A list item with a code block:</span><br><span class="line"></span><br><span class="line"><span class="code">      &lt;code goes here&gt;</span></span><br></pre></td></tr></table></figure>

<p>有时候无意中出发有序列表, 如下面这样的代码:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1986.</span> What a great season.</span><br></pre></td></tr></table></figure>
<p>即使, 如果一行开头满足 number-period-space 模式. 可以通过转义点号来避免这种情况:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1986\. What a great season.</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>略</p>
<h2 id="代码块和代码"><a href="#代码块和代码" class="headerlink" title="代码块和代码"></a>代码块和代码</h2><h3 id="文档-3"><a href="#文档-3" class="headerlink" title="文档"></a>文档</h3><ul>
<li> 代码块<blockquote>
<p>预格式化的代码块用于输出编程语言和标记语言. 不同于普通段落, 代码块中的行会被原样呈现. Markdown 会用 <pre> 和 <code> 标签包围代码块.</code></pre></p>
<p>要在 Markdown 中插入代码块, 只需要将每一行都缩进 4 个空格或者 1 个水平制表符. 例如, 下面的输入:</p>
<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>
<p>Markdown 会生成:</p>
<pre><code>&lt;p&gt;This is a normal paragraph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;
</code></pre>
<p>只有一级缩进 – 4 个空格或者 1 个水平制表符 – 会从代码块中的每一行中移除. 例如:</p>
<pre><code>Here is an example of AppleScript:
                                                        
tell application &quot;Foo&quot;
    beep
end tell
</code></pre>
<p>会生成:</p>
<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre>
</blockquote>
</li>
<li>  代码<blockquote>
<p>要输出一个代码片段, 需要使用重音符号 (`). 不同于预格式的代码块, 代码片段只是在普通段落中标识出代码. 例如:</p>
<pre><code> Use the `printf()` function.
</code></pre>
<p>会生成:</p>
<pre><code> &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre>
<p>要在代码片段中包含字面量的重音符号, 可以使用多个重音符号作为起始和结束标记:</p>
<pre><code> ``There is a literal backtick (`) here.``
</code></pre>
<p>会生成:</p>
<pre><code> &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre>
<p>包含代码片段的重音符号可以包含空格 – 起始标记后一个, 结束标记前一个. 这使你可以在代码片段开始和结束位置使用重音符号的字面量:</p>
<pre><code> A single backtick in a code span: `` ` ``
                   
 A backtick-delimited string in a code span: `` `foo` ``
</code></pre>
<p>会生成:</p>
<pre><code> &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;
                   
 &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre>
<p>在代码片段中, 英镑符号和尖括号会被转换成相应的字符实体, 这使得包含 HTML 标签很容易. Markdown 会将下面的代码:</p>
<pre><code> Please don&#39;t use any `&lt;blink&gt;` tags.
</code></pre>
<p> 转成:</p>
<pre><code> &lt;p&gt;Please don&#39;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre>
<p>这样写:</p>
<pre><code> `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre>
<p>会生成:</p>
<pre><code> &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
 equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="文档总结和补充"><a href="#文档总结和补充" class="headerlink" title="文档总结和补充"></a>文档总结和补充</h3><ol>
<li>   选中写好了的代码，然后tab缩进就好了。</li>
<li>   还有一种是通过一对  `` (英文状态下tab键上面那个) 或者 ~~~  (英文状态下shift+tab上面那个) 将代码包起来。三个反撇号和三个波浪号各一行。再第一个```或~~~后可以加上代码的语言，这样可以有更好的显示效果。</li>
</ol>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5>  要加粗的文字左右分别用两个*号包起来</li>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5>  要倾斜的文字左右分别用一个*号包起来</li>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5> 要倾斜和加粗的文字左右分别用三个*号包起来</li>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5>  要加删除线的文字左右分别用两个~~号包起来<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4>  <strong>这是加粗的文字</strong><br>  <em>这是倾斜的文字</em><br>  <em><strong>这是倾斜加粗的文字</strong></em><br>  <del>这是添加删除线</del><h4 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h4></li>
</ul>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><em><strong>这是倾斜加粗的文字</strong></em><br><del>这是添加删除线</del></p>
<h3 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.  分割线"></a>4.  分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><pre><code>---
----
***
****
</code></pre>
<h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><hr>
<hr>
<hr>
<hr>
<h3 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h3><h4 id="语法-amp-示例"><a href="#语法-amp-示例" class="headerlink" title="语法&amp;示例"></a>语法&amp;示例</h4><pre><code>本地：
  ![狗]（markdown语法/dog.jpg &quot;狗&quot;）
</code></pre>
<h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><img src="/2021/08/05/markdown%E8%AF%AD%E6%B3%95/dog.jpg" class title="狗">



<img src="/2021/08/05/markdown%E8%AF%AD%E6%B3%95/dog.jpg" width="256" height="256">

 <img src="/2021/08/05/markdown%E8%AF%AD%E6%B3%95/dog.jpg" class title="狗">{:width="30px" height="10px"}]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_57|. 出界的路径数</title>
    <url>/2021/08/20/Leetcode-57-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>57|. 出界的路径数</p>
<p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>

<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img style="width: 500px; height: 296px;" src="https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png" alt>
<pre><strong>输入：</strong>m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
<strong>输出：</strong>6
</pre>

<p><strong>示例 2：</strong></p>
<img style="width: 500px; height: 293px;" src="https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png" alt>
<pre><strong>输入：</strong>m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1
<strong>输出：</strong>12
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= m, n &lt;= 50</code></li>
    <li><code>0 &lt;= maxMove &lt;= 50</code></li>
    <li><code>0 &lt;= startRow &lt; m</code></li>
    <li><code>0 &lt;= startColumn &lt; n</code></li>
</ul>

<h3 id="f方法一：-动态规划"><a href="#f方法一：-动态规划" class="headerlink" title="f方法一： 动态规划"></a>f方法一： 动态规划</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这一题显然是要用动态规划来做。状态也不难写，<code>dp[move][r][c]</code>表示第<code>move</code>步走到第<code>r</code>行第<code>c</code>列的数量。状态转移方程也不难想到，即<code>dp[move][r][c]</code>等于<code>move-1</code>上一步步第<code>r</code>行第<code>c</code>列上下左右四个数的和，当然这是要在范围内，这里需要一个判断。而我的代码实现当中，是将这一步第<code>r</code>行第<code>c</code>列上下左右四个数加到下一步去。<br>较为复杂的我认为是在对于边界一圈的情况的考虑。如果球走到边界上了，剩余的步数至少还有一步，那他就可以出界，而且有多少种情况能走到边界的这个位置就有多少种出界的情况。但就如题目中的示例那样，边界的不同位置出界的可能i性是不同的。所以，我是在循环当中，先判断这个位置是不是边界以及是哪一种边界，如果是，再判断这个位置上是不是0，如果不是0，说明可以出界，那就将它加到出界总数去，一种边界加一次，这样就解决了边界不同位置有不同出界的可能性。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def findPaths(m, n, maxMove, startRow, startColumn):</span><br><span class="line">    if maxMove == 0:</span><br><span class="line">        return 0</span><br><span class="line">    dp = [[[0 for c in range(n)] for r in range(m)] for move in range(maxMove)]</span><br><span class="line">    outCounts = 0</span><br><span class="line">    dp[0][startRow][startColumn] = 1</span><br><span class="line">    for move in range(maxMove):</span><br><span class="line">        for r in range(m):</span><br><span class="line">            for c in range(n):</span><br><span class="line">                if r == 0 or c == 0 or r == m-1 or c == n-1:</span><br><span class="line">                    t = dp[move][r][c]</span><br><span class="line">                    if t != 0:</span><br><span class="line">                        if r-1 &lt; 0:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if c-1 &lt; 0:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if r+1 == m:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if c+1 == n:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                if move == maxMove-1:</span><br><span class="line">                    continue</span><br><span class="line">                for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:</span><br><span class="line">                    if i &gt;= 0 and i &lt; m and j &gt;= 0 and j &lt; n:</span><br><span class="line">                        dp[move+1][r][c] += dp[move][i][j]</span><br><span class="line"></span><br><span class="line">    return outCounts % (10**9+7)</span><br></pre></td></tr></table></figure>

<h3 id="方法二：-卷积"><a href="#方法二：-卷积" class="headerlink" title="方法二： 卷积"></a>方法二： 卷积</h3><p>大佬都在评论区。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">m, n, maxMove, startRow, startColumn</span>):</span></span><br><span class="line">    <span class="keyword">if</span> maxMove &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a = numpy.zeros((m, n), )</span><br><span class="line">    a[startRow, startColumn] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    b = numpy.zeros((<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">int</span>)</span><br><span class="line">    b[<span class="number">0</span>][<span class="number">1</span>] = b[<span class="number">1</span>][<span class="number">0</span>] = b[-<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>][-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(a)</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(maxMove):</span><br><span class="line">        ans += (a[:, <span class="number">0</span>].<span class="built_in">sum</span>() + a[:, -<span class="number">1</span>].<span class="built_in">sum</span>() +</span><br><span class="line">                a[<span class="number">0</span>, :].<span class="built_in">sum</span>() + a[-<span class="number">1</span>, :].<span class="built_in">sum</span>()) % <span class="number">1_000_000_007</span></span><br><span class="line">        a = scipy.signal.convolve2d(a, b, <span class="string">&#x27;same&#x27;</span>) % <span class="number">1_000_000_007</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(ans) % <span class="number">1_000_000_007</span></span><br></pre></td></tr></table></figure>

<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fXAdy9"><img src="https://z3.ax1x.com/2021/08/20/fXAdy9.jpg" alt="t提交记录1.jpg"></a><br><a href="https://imgtu.com/i/fXAaQJ"><img src="https://z3.ax1x.com/2021/08/20/fXAaQJ.jpg" alt="提交记录2.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
</search>
