<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode_345. 反转字符串中的元音字母</title>
    <url>/2021/08/19/Leetcode-345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>345. 反转字符串中的元音字母<br>难度：简单<br>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：”hello”<br>输出：”holle”<br>示例 2：</p>
<p>输入：”leetcode”<br>输出：”leotcede”</p>
<p>提示：</p>
<p>元音字母不包含字母 “y” 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">https://leetcode-cn.com/problems/reverse-vowels-of-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p>这提不难。<br>弄两个指针<code>i</code>和<code>j</code>，<code>i</code>从前往后走，<code>j</code>从后往前走，当遇到原因字母的时候，就停下来。当两个指针都停下来的时候，交换两个字母。使用<code>while</code>循环，退出条件是<code>i</code>和<code>j</code>重合。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>python<pre><code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def reverseVowels(s):</span><br><span class="line">l = list(s)</span><br><span class="line">i, j = 0, len(s)-1</span><br><span class="line">Vowels = [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;A&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;U&#x27;]</span><br><span class="line"># vowels = &quot;aeiouAEIOU&quot;</span><br><span class="line">i_step = 1</span><br><span class="line">j_step = -1</span><br><span class="line">while i &lt; j:</span><br><span class="line">    if l[i] in Vowels:</span><br><span class="line">        i_step = 0</span><br><span class="line">    if l[j] in Vowels:</span><br><span class="line">        j_step = 0</span><br><span class="line"></span><br><span class="line">    if i_step == j_step == 0:</span><br><span class="line">        l[i], l[j] = l[j], l[i]</span><br><span class="line">        i_step = 1</span><br><span class="line">        j_step = -1</span><br><span class="line">    i += i_step</span><br><span class="line">    j += j_step</span><br><span class="line">return &#x27;&#x27;.join(l)</span><br></pre></td></tr></table></figure>
</code></pre>
  和官方题解几乎一样。</li>
<li>C<pre><code> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   	<span class="function"><span class="keyword">int</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> vowels[] = <span class="string">&quot;aeiouAEIOU&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; vowels[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == vowels[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseVowels</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">strlen</span>(s)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> tmp = s[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> i_step = <span class="number">1</span>, j_step = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> == isVowel(s[i]))</span><br><span class="line">			i_step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> == isVowel(s[j]))</span><br><span class="line">			j_step = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i_step == <span class="number">0</span> &amp;&amp; j_step == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c %c %s\n&quot;</span>, s[i], s[j], s);</span><br><span class="line">			tmp = s[i];</span><br><span class="line">			s[i] = s[j];</span><br><span class="line">			s[j] = tmp;</span><br><span class="line">			i_step = <span class="number">1</span>;</span><br><span class="line">			j_step = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i += i_step;</span><br><span class="line">		j += j_step;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fHEmKP"><img src="https://z3.ax1x.com/2021/08/19/fHEmKP.jpg" alt="python提交记录"></a><br><a href="https://imgtu.com/i/fHEZvt"><img src="https://z3.ax1x.com/2021/08/19/fHEZvt.jpg" alt="C语言提交记录"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_1583. 统计不开心的朋友</title>
    <url>/2021/08/20/Leetcode-1583-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>1583. 统计不开心的朋友<br>难度：中等</p>
<p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code> 总是 <strong>偶数</strong> 。</p>

<p>对每位朋友 <code>i</code>，<code>preferences[i]</code> 包含一份 <strong>按亲近程度从高</strong><strong>到低排列</strong> 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code> 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 <code>0</code> 到 <code>n-1</code> 之间的整数表示。</p>

<p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <code>x<sub>i</sub></code> 与 <code>y<sub>i</sub></code> 配对，且 <code>y<sub>i</sub></code> 与 <code>x<sub>i</sub></code> 配对。</p>

<p>但是，这样的配对情况可能会使其中部分朋友感到不开心。在 <code>x</code> 与 <code>y</code> 配对且 <code>u</code> 与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，<code>x</code> 就会不开心：</p>

<ul>
    <li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li>
    <li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li>
</ul>

<p>返回 <strong>不开心的朋友的数目</strong> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]
<strong>输出：</strong>2
<strong>解释：</strong>
朋友 1 不开心，因为：
- <strong>1 与 0 </strong>配对，但 <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高，且
- <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高。
朋友 3 不开心，因为：
- 3 与 2 配对，但 <strong>3 与 1</strong> 的亲近程度比 <strong>3 与 2</strong> 高，且
- <strong>1 与 3</strong> 的亲近程度比 <strong>1 与 0</strong> 高。
朋友 0 和 2 都是开心的。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 2, preferences = [[1], [0]], pairs = [[1, 0]]
<strong>输出：</strong>0
<strong>解释：</strong>朋友 0 和 1 都开心。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]
<strong>输出：</strong>4
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>2 &lt;= n &lt;= 500</code></li>
    <li><code>n</code> 是偶数</li>
    <li><code>preferences.length&nbsp;== n</code></li>
    <li><code>preferences[i].length&nbsp;== n - 1</code></li>
    <li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li>
    <li><code>preferences[i]</code> 不包含 <code>i</code></li>
    <li><code>preferences[i]</code> 中的所有值都是独一无二的</li>
    <li><code>pairs.length&nbsp;== n/2</code></li>
    <li><code>pairs[i].length&nbsp;== 2</code></li>
    <li><code>x<sub>i</sub> != y<sub>i</sub></code></li>
    <li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n - 1</code></li>

<li>每位朋友都 <strong>恰好</strong> 被包含在一对中</li>
</ul>

<h3 id="方法一：-模拟"><a href="#方法一：-模拟" class="headerlink" title="方法一： 模拟"></a>方法一： 模拟</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题看起来非常非常非常复杂，但其实重点再那两个且的条件：</p>
<blockquote>
<ul>
<li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li>
<li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li>
</ul>
</blockquote>
<p>因此我们的做法就是：</p>
<ol>
<li>找到一个<code>x</code>，以及和他配对的<code>y</code>;</li>
<li>在<code>x</code>的<code>preferences</code>里遍历，在没有遇到<code>y</code>之前，每一个都是可能的<code>u</code>;（这时满足了第一个条件）</li>
<li>在找到与这个<code>u</code>配对的<code>v</code>，然后在<code>u</code>的<code>preferences</code>里找<code>x</code>和<code>v</code>的下标关系是否满足第二个条件，即如果在<code>u</code>的<code>preferences</code>里<code>x</code>的下标小于<code>v</code>的下标，那么，<code>x</code>就是不开心的。<br>为了找所有不开心的<code>x</code>，那么，就是要遍历所有人，同时还要方便找到与它配对的<code>y</code>，所以再开始的时候先创建一个字典，用于记录每个人和谁配对。<br>具体代码实现的时候，还有一个<code>x_isunhappy</code>用于标记<code>x</code>是不是不开心的，如果是，就可以去下一个<code>x</code>了。<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unhappyFriends</span>(<span class="params">n, preferences, pairs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    unhappy = <span class="number">0</span></span><br><span class="line">    pairs_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">        pairs_dict[x] = y</span><br><span class="line">        pairs_dict[y] = x</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        y = pairs_dict[x]</span><br><span class="line">        x_isunhappy = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> preferences[x]:</span><br><span class="line">            <span class="keyword">if</span> u == y <span class="keyword">or</span> x_isunhappy == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            v = pairs_dict[u]</span><br><span class="line">            <span class="keyword">if</span> preferences[u].index(x) &lt; preferences[u].index(v):</span><br><span class="line">                x_isunhappy = <span class="literal">True</span></span><br><span class="line">                unhappy += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unhappy</span><br></pre></td></tr></table></figure>
官方的方法和我的几乎一样。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -&gt; int:</span><br><span class="line">        order = [[0] * n for _ in range(n)]</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(n - 1):</span><br><span class="line">                order[i][preferences[i][j]] = j</span><br><span class="line">        </span><br><span class="line">        match = [0] * n</span><br><span class="line">        for x, y in pairs:</span><br><span class="line">            match[x] = y</span><br><span class="line">            match[y] = x</span><br><span class="line"></span><br><span class="line">        unhappyCount = 0</span><br><span class="line">        for x in range(n):</span><br><span class="line">            y = match[x]</span><br><span class="line">            index = order[x][y]</span><br><span class="line">            for i in range(index):</span><br><span class="line">                u = preferences[x][i]</span><br><span class="line">                v = match[u]</span><br><span class="line">                if order[u][x] &lt; order[u][v]:</span><br><span class="line">                    unhappyCount += 1</span><br><span class="line">                    break</span><br><span class="line">        </span><br><span class="line">        return unhappyCount</span><br><span class="line"></span><br><span class="line"># 作者：LeetCode-Solution</span><br><span class="line"># 链接：https://leetcode-cn.com/problems/count-unhappy-friends/solution/tong-ji-bu-kai-xin-de-peng-you-by-leetcode-solutio/</span><br><span class="line"># 来源：力扣（LeetCode）</span><br><span class="line"># 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fXcVKK"><img src="https://z3.ax1x.com/2021/08/20/fXcVKK.jpg" alt="提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Leetcode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_443. 压缩字符串</title>
    <url>/2021/08/22/Leetcode-443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>443. 压缩字符串<br>难度：中等</p>
<p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p>

<p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p>

<ul>
    <li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li>
    <li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li>
</ul>

<p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p>

<p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p>

<p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>chars = ["a","a","b","b","c","c","c"]
<strong>输出：</strong>返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
<strong>解释：</strong>
"aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>chars = ["a"]
<strong>输出：</strong>返回 1 ，输入数组的前 1 个字符应该是：["a"]
<strong>解释：</strong>
没有任何字符串被替代。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>chars = ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
<strong>输出：</strong>返回 4 ，输入数组的前 4 个字符应该是：["a","b","1","2"]。
<strong>解释：</strong>
由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。
注意每个数字在数组中都有它自己的位置。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= chars.length &lt;= 2000</code></li>
    <li><code>chars[i]</code> 可以是小写英文字母、大写英文字母、数字或符号</li>
</ul>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>要注意理解题目中确实是要将<code>chars</code>里的内容给改掉的。<br>我的第一个方法是另外创建一个<code>s</code>，初始就为<code>chars[0]</code>，然后遍历<code>chars</code>，用一个变量<code>c</code>来记相同的个数，直到遇到的字符与<code>s[-1]</code>不一样或者到了最后一个，就将计数器<code>s</code>强制转换乘字符串并一个一个加到<code>s</code>里去。最后再将<code>chars</code>里的字符一个个改掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span>(<span class="params">chars</span>):</span></span><br><span class="line">    s = [chars[<span class="number">0</span>]]</span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    n = <span class="built_in">len</span>(chars)</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">if</span> s[-<span class="number">1</span>] != chars[i]:</span><br><span class="line">            <span class="keyword">if</span> c != <span class="number">1</span>:</span><br><span class="line">                s.extend(<span class="built_in">list</span>(<span class="built_in">str</span>(c)))</span><br><span class="line">            s.append(chars[i])</span><br><span class="line">            c = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == n-<span class="number">1</span>:</span><br><span class="line">                s.extend(<span class="built_in">list</span>(<span class="built_in">str</span>(c)))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        chars[i] = x</span><br><span class="line">    <span class="comment"># print(chars)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure>

<h3 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><p>不创建新的列表或字符串，在原有的列表上直接修改。<br>（其实是三指针）设一个写指针，两个读指针。大思路并不难，主要是具体实现上需要有些注意。比如，<code>if right == n-1 or chars[right] != chars[right+1]:</code>这句，①将是不是到了最后一个位置的判断放在<code>or</code>前面，②判断两个字符是否相等，是判断指针和它的下一个是不是一样，而不是往前判断，这样就可以解决好多最后一个字符的情况（往后判断的话，需要考虑最后一个是否与前一个相等的情况，会麻烦一些）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span>(<span class="params">chars</span>):</span></span><br><span class="line">    write = left = <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(chars)</span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> right == n-<span class="number">1</span> <span class="keyword">or</span> chars[right] != chars[right+<span class="number">1</span>]:</span><br><span class="line">            l = right-left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(l):</span><br><span class="line">                    write += <span class="number">1</span></span><br><span class="line">                    chars[write] = i</span><br><span class="line">            left = right+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right != n-<span class="number">1</span>:</span><br><span class="line">                write += <span class="number">1</span></span><br><span class="line">                chars[write] = chars[right+<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(chars[:write+1])</span></span><br><span class="line">    <span class="keyword">return</span> write+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hSKTDP"><img src="https://z3.ax1x.com/2021/08/22/hSKTDP.jpg" alt="压缩字符串提交记录jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>Leetcode中等</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_526. 优美的排列</title>
    <url>/2021/08/18/Leetcode-526-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>526. 优美的排列<br>难度：中等<br>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p>
<p>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？</p>
<p>示例1:</p>
<p>输入: 2<br>输出: 2<br>解释: </p>
<p>第 1 个优美的排列是 [1, 2]:<br>  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</p>
<p>第 2 个优美的排列是 [2, 1]:<br>  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除<br>说明:</p>
<p>N 是一个正整数，并且不会超过15。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/beautiful-arrangement">https://leetcode-cn.com/problems/beautiful-arrangement</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法零：流氓方法"><a href="#方法零：流氓方法" class="headerlink" title="方法零：流氓方法"></a>方法零：流氓方法</h3><p>因为题目说明了N不会超过15，那就用例测试所有的数得到答案，然后用列表或者一串<code>if</code>语句就可以通过了。</p>
<h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>本来就隐约觉得会用到回溯算法，但还是想先用排列组合的方法试一下，但太太困难了，最后还是用了回溯算法。<br>先创建一个字典<code>d</code>，可以理解成键是第几个位置，对应的值是该位置上能放哪些数。<br>接下来是回溯函数，设置两个参数，第一个是用于记录当前状态的列表，第二个是 现在要填的是哪一个位置<code>pos</code>，返回当前状态下的优美排列数<code>c</code>。<br><code>c</code>初始设为0，<code>i</code>遍历可以在<code>pos</code>位置上的所有数，即<code>d[pos]</code>，如果<code>i</code>不在列表之内，就将它填到列表的对应位置上，并<code>c += func(s, pos+1)</code>，递归到下一个<code>pos</code>中，直到<code>pos==n</code>时，<code>c += 1</code>。<br>可能还是直接看代码清楚一些吧。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def countArrangement(n):</span><br><span class="line">    d = defaultdict(list)</span><br><span class="line">    # 第num个位置上可以放哪些数</span><br><span class="line">    for num in range(1, n+1):</span><br><span class="line">        for i in range(1, num+1):</span><br><span class="line">            if num % i == 0:</span><br><span class="line">                d[num].append(i)</span><br><span class="line">                if num != i:</span><br><span class="line">                    d[i].append(num)</span><br><span class="line"></span><br><span class="line">    def func(s, pos):</span><br><span class="line">        c = 0</span><br><span class="line">        for i in d[pos]:</span><br><span class="line">            if i not in s:</span><br><span class="line">                s[pos-1] = i</span><br><span class="line">                if pos == n:</span><br><span class="line">                    c += 1</span><br><span class="line">                else:</span><br><span class="line">                    c += func(s, pos+1)</span><br><span class="line">                s[pos-1] = 0</span><br><span class="line">        return c</span><br><span class="line">    return func([0]*n, 1)</span><br></pre></td></tr></table></figure>
<p>官方的回溯算法和我写得几乎一样，只是他用的是集合。我一开始也是想用集合的，但不知道集合的<code>disturb</code>方法，才改成了列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countArrangement(self, n: int) -&gt; int:</span><br><span class="line">        match = defaultdict(list)</span><br><span class="line">        for i in range(1, n + 1):</span><br><span class="line">            for j in range(1, n + 1):</span><br><span class="line">                if i % j == 0 or j % i == 0:</span><br><span class="line">                    match[i].append(j)</span><br><span class="line">        </span><br><span class="line">        num = 0</span><br><span class="line">        vis = set()</span><br><span class="line"></span><br><span class="line">        def backtrack(index: int) -&gt; None:</span><br><span class="line">            if index == n + 1:</span><br><span class="line">                nonlocal num</span><br><span class="line">                num += 1</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            for x in match[index]:</span><br><span class="line">                if x not in vis:</span><br><span class="line">                    vis.add(x)</span><br><span class="line">                    backtrack(index + 1)</span><br><span class="line">                    vis.discard(x)</span><br><span class="line">                   </span><br><span class="line">        backtrack(1)</span><br><span class="line">        return num</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/beautiful-arrangement/solution/you-mei-de-pai-lie-by-leetcode-solution-vea2/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="方法二：状态压缩-动态规划"><a href="#方法二：状态压缩-动态规划" class="headerlink" title="方法二：状态压缩+动态规划"></a>方法二：状态压缩+动态规划</h3><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>这个方法实在难理解，借助官方题解下的评论才勉强看懂。也不知道什么叫状态压缩。<br>首先，是动态规划的状态表示。这里用二进制数表示，从右往左数，第<code>i</code>位上的数字是1，就表示<code>i</code>这个数字被选取了。创建长度为<code>1&lt;&lt;n</code>的数组<code>f</code>，表示某一状态下的优美排列数。<br>以<code>n=6</code>举例。<code>f[000110]</code>的意思是（这里下标里的数都是二进制数）：数字2和3能够组成的优美排列数。<br>所以，最后返回的结果就是<code>f[1&lt;&lt;n -1]</code>，即<code>f[111111]</code>。<br>然后是转移方程。<code>f[111111] = f[011111] + f[101111] + f[110111] + f[111011] + f[111101] + f[111110]</code>，也就是说，要算取了6个数的优美排列，就算上所有任意去掉这已经取了的6个数中的一个的状态的优美排列数。当然，事实上并不是所有的数都要相加，因为还需要判断，去掉的那个数能否放在第6个位置上。比如<code>f[101111]</code>这时数字<code>5</code>还没有取，而<code>5</code>并不能放在第6个位置上。<br>再举个例子。<code>f[100110]</code>是要算数字<code>2</code>、<code>3</code>和<code>6</code>这3个数的优美排列，那就看哪个数可以放在第3个位置上，这里<code>6</code>和<code>3</code>可以放在第3个位置上，而这时候已经取了的数字分别是<code>2</code>、<code>3</code>和<code>2</code>、<code>6</code>所以<code>f[100110] = f[000110] + f[100010]</code>。<br>因此，设计双重循环，外层<code>mask</code>循环遍历所有状态，内存<code>i</code>循环做的事情是从0（最右边）开始遍历<code>mask</code>的每一位，如果第<code>i+1</code>位上是<code>1</code>，并且这个<code>1</code>对应的数<code>i+1</code>能放在这个位置上（这句话的意思是：假装还没有取<code>i+1</code>这个数，此时已经取了<code>num - 1</code>个数，那 <code>i+1</code>能否放在<code>num</code>这个位置上，所以，<code>num</code>的意思就是要求的<code>mask</code>当中已经取了的数的数量，所以，<code>num</code>可以通过统计<code>mask</code>中有几个<code>1</code>来获得），那么<code>f[mask]</code>就可以加上这种状态下的优美排列数了。<br>还是结合代码进行理解吧。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def countArrangement(n):</span><br><span class="line">    # f[X] X是一个二进制数，</span><br><span class="line">    # 例：f[000110]，表示数字2和3被选取后排在前面的优美排列数</span><br><span class="line">    # 从右往左数，1表示被选</span><br><span class="line">    f = [0]*(1 &lt;&lt; n)</span><br><span class="line">    f[0] = 1</span><br><span class="line"></span><br><span class="line">    # 动态规划，mask 遍历1到 1&lt;&lt;n</span><br><span class="line">    for mask in range(1, 1 &lt;&lt; n):</span><br><span class="line">        # 计mask有多少个1</span><br><span class="line">        # 以100110举例例，mum=3</span><br><span class="line">        # 也就是说，2、3、6被选取了，要放在前三个求他们呢的优美排列数</span><br><span class="line">        # 那需要判断第3个位置（也就是第 num个位置）可以放谁，</span><br><span class="line">        # 这里可以放3和6，</span><br><span class="line">        # 前两个位置是2，6，f[100110] += f[100010]</span><br><span class="line">        # 前两个位置是2，3，f[100110] += f[000110]</span><br><span class="line">        num = bin(mask).count(&quot;1&quot;)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            # mask &amp; (1 &lt;&lt; i  mask的第i+1位是不是1</span><br><span class="line">            # 如果是，</span><br><span class="line">            # i+1这个数能不能放在 num 这个位置上</span><br><span class="line">            # 如果可以，</span><br><span class="line">            # mask ^ (1 &lt;&lt; i) mask的第i+1位改为0</span><br><span class="line">            # f[mask] += f[mask ^ (1 &lt;&lt; i)]</span><br><span class="line">            # 注意i与i+1，i-1的区别含义</span><br><span class="line">            if (mask &amp; (1 &lt;&lt; i) and (num % (i+1) == 0 or (i+1) % num == 0)):</span><br><span class="line">                f[mask] += f[mask ^ (1 &lt;&lt; i)]</span><br><span class="line">        # for i in range(1,n+1):</span><br><span class="line">        #     if (mask &amp; (1 &lt;&lt; (i-1)) and (num % i == 0 or i % num == 0)):</span><br><span class="line">        #         f[mask] += f[mask ^ (1 &lt;&lt; (i-1))]</span><br><span class="line">    return f[(1 &lt;&lt; n)-1]</span><br></pre></td></tr></table></figure>


<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><img src="https://z3.ax1x.com/2021/08/18/fI1buR.jpg" alt="526. 优美的排列提交记录"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_541. 反转字符串 II</title>
    <url>/2021/08/20/Leetcode-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>541. 反转字符串 II<br>难度：简单</p>
<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每 <code>2k</code> 个字符反转前 <code>k</code> 个字符。</p>

<ul>
    <li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
    <li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>s = "abcdefg", k = 2
<strong>输出：</strong>"bacdfeg"
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>s = "abcd", k = 2
<strong>输出：</strong>"bacd"
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
    <li><code>s</code> 仅由小写英文组成</li>
    <li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>
</ul>


<h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p>难度不大，直接上代码、</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseStr</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        t = <span class="built_in">list</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(t), <span class="number">2</span> * k):</span><br><span class="line">            t[i: i + k] = <span class="built_in">reversed</span>(t[i: i + k])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def reverseStr(self, s: str, k: int) -&gt; str:</span></span><br><span class="line"><span class="comment">#         kk = 2*k</span></span><br><span class="line"><span class="comment">#         n = len(s)</span></span><br><span class="line"><span class="comment">#         i, j = 0, k-1</span></span><br><span class="line"><span class="comment">#         st = list(s)</span></span><br><span class="line"><span class="comment">#         while i &lt; n:</span></span><br><span class="line"><span class="comment">#             start, end = i, j</span></span><br><span class="line"><span class="comment">#             if j &gt;= n:</span></span><br><span class="line"><span class="comment">#                 end = n-1</span></span><br><span class="line"><span class="comment">#             # print(i, j, start, end, n)</span></span><br><span class="line"><span class="comment">#             while start &lt; end:</span></span><br><span class="line"><span class="comment">#                 st[start], st[end] = st[end], st[start]</span></span><br><span class="line"><span class="comment">#                 start += 1</span></span><br><span class="line"><span class="comment">#                 end -= 1</span></span><br><span class="line"><span class="comment">#             i += kk</span></span><br><span class="line"><span class="comment">#             j += kk</span></span><br><span class="line"><span class="comment">#         return &#x27;&#x27;.join(st)</span></span><br></pre></td></tr></table></figure>
<p>注释掉的是我的，没注释掉的是官方的。可见对python的有些东西还是不熟悉。</p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fOVZSe"><img src="https://z3.ax1x.com/2021/08/20/fOVZSe.jpg" alt="通过.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_551. 学生出勤记录 I</title>
    <url>/2021/08/17/Leetcode-551-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-I/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>551.-学生出勤记录-I<br>难度：简单<br>给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<p>‘A’：Absent，缺勤<br>‘L’：Late，迟到<br>‘P’：Present，到场<br>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：</p>
<p>按 总出勤 计，学生缺勤（’A’）严格 少于两天。<br>学生 不会 存在 连续 3 天或 3 天以上的迟到（’L’）记录。<br>如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。</p>
<p>示例 1：</p>
<p>输入：s = “PPALLP”<br>输出：true<br>解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。<br>示例 2：</p>
<p>输入：s = “PPALLL”<br>输出：false<br>解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000<br>s[i] 为 ‘A’、’L’ 或 ‘P’</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/student-attendance-record-i">https://leetcode-cn.com/problems/student-attendance-record-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>太简单了，略</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>python<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def checkRecord(self, s: str) -&gt; bool:</span><br><span class="line">        return s.count(&quot;A&quot;)&lt;2 and s.count(&quot;LLL&quot;)&lt;=0</span><br></pre></td></tr></table></figure></li>
<li>C<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> absent = <span class="number">0</span>, late = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*s == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			absent++;</span><br><span class="line">			late = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (absent == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*s == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			late++;</span><br><span class="line">			<span class="keyword">if</span> (late == <span class="number">3</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			late = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/f4KPi9"><img src="https://z3.ax1x.com/2021/08/17/f4KPi9.png" alt="551. 学生出勤记录 I.png"></a><br><a href="https://imgtu.com/i/f4h6TP"><img src="https://z3.ax1x.com/2021/08/17/f4h6TP.jpg" alt="551. 学生出勤记录 IC语言"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_552. 学生出勤记录 II</title>
    <url>/2021/08/19/Leetcode-552-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-II/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>552. 学生出勤记录 II<br>难度：困难<br>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<ul>
    <li><code>'A'</code>：Absent，缺勤</li>
    <li><code>'L'</code>：Late，迟到</li>
    <li><code>'P'</code>：Present，到场</li>
</ul>

<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>

<ul>
    <li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>
    <li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>
</ul>

<p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>8
<strong>解释：
</strong>有 8 种长度为 2 的记录将被视为可奖励：
"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>3
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 10101
<strong>输出：</strong>183236316
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>



<h3 id="方法一和方法二：我的动态规划-排列组合（-泰波纳契数列）"><a href="#方法一和方法二：我的动态规划-排列组合（-泰波纳契数列）" class="headerlink" title="方法一和方法二：我的动态规划+排列组合（+泰波纳契数列）"></a>方法一和方法二：我的动态规划+排列组合（+泰波纳契数列）</h3><p>因为A的情况只有两种：一种是没有A，一种是有A，所以分开考虑。而有A的情况下，A只能有一个，所以考虑将这一个A分别放在字符串的所有位置，这样就将整个字符串分成了左右两个没有A的小部分。若用<code>dp[i]</code>记只有p和L组成的长度为<code>i</code>的字符串当中数量，那么带上A的总数就是将A放在每个位置上的时候<code>dp[A左边长度]*dp[A右边的长度]</code>的总和。而最前面考虑的整个字符串当中没有A的情况即为<code>dp[总长度]</code>。<br>所以接下来就是<code>dp[i]</code>的状态转移方程了。这里再建立两个状态，<code>present[i]</code>和<code>late[i]</code>，分别用于表示长度为<code>i</code>时候以P和L开头（或结尾，其实一样的）的符合条件的数量。于是有状态转移方程：</p>
<ul>
<li><code>present[i] = present[i-1]+late[i-1]</code><br> 因为P可以既可以接在P后边，也可以接在L后边。 </li>
<li><code>late[i] = present[i-1]+present[i-2]</code><br> 因为L可以接在两种情况后边：①恨着P；②只有一个L，这种时候就需要隔着一位是P了。</li>
<li><code>dp[i] = present[i]+late[i]</code><br>这样就可以写代码了。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    dp, late, present = [<span class="number">0</span>]*(n+<span class="number">1</span>), [<span class="number">0</span>]*(n+<span class="number">1</span>), [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># dp, late, present = &#123;&#125;, &#123;&#125;, &#123;&#125;</span></span><br><span class="line">    present[<span class="number">0</span>] = late[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    present[<span class="number">1</span>] = late[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    present[<span class="number">2</span>] = late[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">        present[i] = present[i-<span class="number">1</span>]+late[i-<span class="number">1</span>]</span><br><span class="line">        late[i] = present[i-<span class="number">1</span>]+present[i-<span class="number">2</span>]</span><br><span class="line">        dp[i] = (present[i]+late[i]) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">    <span class="comment"># print(present)</span></span><br><span class="line">    <span class="comment"># print(dp)</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        t = dp[i]*dp[n-<span class="number">1</span>-i]</span><br><span class="line">        ret += t % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">    ret += dp[n]</span><br><span class="line">    <span class="keyword">return</span> ret % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
初始状态可以人工算出。<br>我以为我的思路那么简单清晰易懂，肯定没有问题（虽然确实可以解），但是提交之后超出时间限制了！以为因为中间没有每一步都取模（刚开始的时候没有）会导致大数运算变慢，于是每一步都加上取模运算；以为因为是列表取值慢于是有改成字典；以为网断了（其实并没有），重新连了网——而这些都没有用！<br>后来觉得可能是循环里头<code>[]</code>的取值操作有点多，于是将状态转移方程展开往下写，发现这里竟然有个泰波纳契数列。<br>dp[i]<br>= present[i]+late[i]<br>=present[i-1]+late[i-1]+present[i-1]+present[i-2]<br>=present[i-1]+(present[i-2]+present[i-3]) + present[i-1]+present[i-2]<br>=2<em>present[i-1]+2</em>present[i-2]+present[i-3]<br>于是“改进”了方法的前面部分。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkRecord2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">19</span></span><br><span class="line">    <span class="comment"># dp = [0]*(n+1)</span></span><br><span class="line">    dp = &#123;&#125;</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>], dp[<span class="number">2</span>], dp[<span class="number">3</span>] = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, n+<span class="number">1</span>):</span><br><span class="line">        dp[i] = a+<span class="number">2</span>*b+<span class="number">2</span>*c</span><br><span class="line">        a, b, c = b, c, a+b+c</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
然而仍然超时。——事实上这种更用时，后面放性能分析。<br><a href="https://imgtu.com/i/fq7VpQ"><img src="https://z3.ax1x.com/2021/08/19/fq7VpQ.jpg" alt="超出时间限制.jpg"></a></li>
</ul>
<h3 id="方法三和方法四：官方的动态规划和我照官方的动态规划"><a href="#方法三和方法四：官方的动态规划和我照官方的动态规划" class="headerlink" title="方法三和方法四：官方的动态规划和我照官方的动态规划"></a>方法三和方法四：官方的动态规划和我照官方的动态规划</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkRecord</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># 长度，A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp = [[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - <span class="number">1</span>][j][k]) % MOD</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][k]) % MOD</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>]) % MOD</span><br><span class="line">        </span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                total += dp[n][j][k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total % MOD</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/student-attendance-record-ii/solution/xue-sheng-chu-qin-ji-lu-ii-by-leetcode-s-kdlm/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>借助他前面的讲解，也并没有很看懂，但了解了大概意思，然后理解着自己写了一个。<br>代码前面部分意思是列举所有情况，开头数字是dp下标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkRecord5</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 0 前面没有A，现在要加P  +=[0]+[1]+[2]</span></span><br><span class="line">    <span class="comment"># 1 前面没有A，上一个不是L，现在要加L  +=[0]</span></span><br><span class="line">    <span class="comment"># 2 前面没有A，上一个是L，现在要加L    +=[1]</span></span><br><span class="line">    <span class="comment"># 3 前面有A，现在要加P   +=[6]+[3]+[4]+[5]</span></span><br><span class="line">    <span class="comment"># 4 前面有A，上一个不是L，现在要加L    +=[6]+[3]</span></span><br><span class="line">    <span class="comment"># 5 前面有A，上一个是L，现在要加L     +=[4]</span></span><br><span class="line">    <span class="comment"># 6 现在要加A  +=[0]+[1]+[2]</span></span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">    <span class="comment"># dp = [[0 for _ in range(7)] for _ in range(n+1)]</span></span><br><span class="line">    <span class="comment"># dp[1] = [1, 1, 0, 0, 0, 0, 1]</span></span><br><span class="line">    <span class="comment"># for i in range(2, n+1):</span></span><br><span class="line">    <span class="comment">#     dp[i][0] += (dp[i-1][0]+dp[i-1][1]+dp[i-1][2])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][1] += dp[i-1][0]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][2] += dp[i-1][1]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][3] += (dp[i-1][6]+dp[i-1][3]+dp[i-1][4]+dp[i-1][5])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][4] += (dp[i-1][6]+dp[i-1][3])% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][5] += dp[i-1][4]% MOD</span></span><br><span class="line">    <span class="comment">#     dp[i][6] += (dp[i-1][0]+dp[i-1][1]+dp[i-1][2])% MOD</span></span><br><span class="line">    <span class="comment"># return sum(dp[n])%MOD</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)], [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)]]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        a, b = i % <span class="number">2</span>, <span class="number">1</span>-i % <span class="number">2</span></span><br><span class="line">        dp[a][<span class="number">0</span>] += (dp[b][<span class="number">0</span>]+dp[b][<span class="number">1</span>]+dp[b][<span class="number">2</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">1</span>] += dp[b][<span class="number">0</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">2</span>] += dp[b][<span class="number">1</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">3</span>] += (dp[b][<span class="number">6</span>]+dp[b][<span class="number">3</span>]+dp[b][<span class="number">4</span>]+dp[b][<span class="number">5</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">4</span>] += (dp[b][<span class="number">6</span>]+dp[b][<span class="number">3</span>]) % MOD</span><br><span class="line">        dp[a][<span class="number">5</span>] += dp[b][<span class="number">4</span>] % MOD</span><br><span class="line">        dp[a][<span class="number">6</span>] += (dp[b][<span class="number">0</span>]+dp[b][<span class="number">1</span>]+dp[b][<span class="number">2</span>]) % MOD</span><br><span class="line">        dp[b] = [<span class="number">0</span>]*<span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(dp[n % <span class="number">2</span>]) % MOD</span><br></pre></td></tr></table></figure>
<p>这里其实也有两个方法，没注释掉的用上了滚动数组，这里需要注意的是清零的这一步<code>dp[b] = [0]*7</code>操作不能忘了。</p>
<h3 id="方法五：-矩阵快速幂"><a href="#方法五：-矩阵快速幂" class="headerlink" title="方法五： 矩阵快速幂"></a>方法五： 矩阵快速幂</h3><p>有我前面列举过所有情况的基础上，写出矩阵快速幂就并不是那么难了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkRecord6</span>(<span class="params">n</span>):</span></span><br><span class="line">    mat = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    ]</span><br><span class="line">    MOD = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="comment"># a[r*m] * b[m*c] = ret[r*c]</span></span><br><span class="line">        r, m, c = <span class="built_in">len</span>(a), <span class="built_in">len</span>(a[<span class="number">0</span>]), <span class="built_in">len</span>(b[<span class="number">0</span>])</span><br><span class="line">        ret = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(c)]<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(r)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    ret[i][j] += a[i][k]*b[k][j]</span><br><span class="line">                    ret[i][j] %= MOD</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixpow</span>(<span class="params">mat, n</span>):</span></span><br><span class="line">        ret = [[<span class="number">1</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ret = multiply(mat, ret)</span><br><span class="line">            mat = multiply(mat, mat)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    ret = matrixpow(mat, n)</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">        ans += i[<span class="number">0</span>] % MOD</span><br><span class="line">    <span class="keyword">return</span> ans % MOD</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><h5 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h5><ul>
<li>动态规划通过<br> <a href="https://imgtu.com/i/fqXhEn"><img src="https://z3.ax1x.com/2021/08/19/fqXhEn.jpg" alt="动态规划通过.jpg"></a></li>
<li>矩阵快速幂（官方）<br> <a href="https://imgtu.com/i/fqXjER"><img src="https://z3.ax1x.com/2021/08/19/fqXjER.jpg" alt="矩阵快速幂（官方）.jpg"></a></li>
<li>矩阵快速幂（自己）<br> <a href="https://imgtu.com/i/fqjVUI"><img src="https://z3.ax1x.com/2021/08/19/fqjVUI.jpg" alt="矩阵快速幂（自己）.jpg"></a></li>
</ul>
</li>
<li><h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5> 用<code>test = [3, 4, 5, 6, 7, 10101, 100000]</code>分别作为输入，用spyder进行性能分析。<br> <a href="https://imgtu.com/i/fqjXQS"><img src="https://z3.ax1x.com/2021/08/19/fqjXQS.jpg" alt="性能分析.jpg"></a><br> 1、2、3、5分别对应前面的方法一、二、三、四。可见泰波纳契数列的”改进“是个灾难啊。6、7分别对应自己和官方的矩阵快速幂。</li>
<li><h5 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h5> 1.真难！不是题目本身，因为虽然是一道困难提，但我还是比较快地有了方法 ，并且能够正确求解，但是总是超时而不清楚原因再哪实在崩溃！<br> 2.<code>1 &lt;= n &lt;= 10<sup>5</sup></code>，10<sup>5</sup>大约是273多年。</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>快速幂/矩阵快速幂</tag>
        <tag>Leetcode困难</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_57|. 出界的路径数</title>
    <url>/2021/08/20/Leetcode-57-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>57|. 出界的路径数<br>难度：简单</p>
<p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>

<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img style="width: 500px; height: 296px;" src="https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png" alt>
<pre><strong>输入：</strong>m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
<strong>输出：</strong>6
</pre>

<p><strong>示例 2：</strong></p>
<img style="width: 500px; height: 293px;" src="https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png" alt>
<pre><strong>输入：</strong>m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1
<strong>输出：</strong>12
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= m, n &lt;= 50</code></li>
    <li><code>0 &lt;= maxMove &lt;= 50</code></li>
    <li><code>0 &lt;= startRow &lt; m</code></li>
    <li><code>0 &lt;= startColumn &lt; n</code></li>
</ul>

<h3 id="f方法一：-动态规划"><a href="#f方法一：-动态规划" class="headerlink" title="f方法一： 动态规划"></a>f方法一： 动态规划</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这一题显然是要用动态规划来做。状态也不难写，<code>dp[move][r][c]</code>表示第<code>move</code>步走到第<code>r</code>行第<code>c</code>列的数量。状态转移方程也不难想到，即<code>dp[move][r][c]</code>等于<code>move-1</code>上一步步第<code>r</code>行第<code>c</code>列上下左右四个数的和，当然这是要在范围内，这里需要一个判断。而我的代码实现当中，是将这一步第<code>r</code>行第<code>c</code>列上下左右四个数加到下一步去。<br>较为复杂的我认为是在对于边界一圈的情况的考虑。如果球走到边界上了，剩余的步数至少还有一步，那他就可以出界，而且有多少种情况能走到边界的这个位置就有多少种出界的情况。但就如题目中的示例那样，边界的不同位置出界的可能i性是不同的。所以，我是在循环当中，先判断这个位置是不是边界以及是哪一种边界，如果是，再判断这个位置上是不是0，如果不是0，说明可以出界，那就将它加到出界总数去，一种边界加一次，这样就解决了边界不同位置有不同出界的可能性。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def findPaths(m, n, maxMove, startRow, startColumn):</span><br><span class="line">    if maxMove == 0:</span><br><span class="line">        return 0</span><br><span class="line">    dp = [[[0 for c in range(n)] for r in range(m)] for move in range(maxMove)]</span><br><span class="line">    outCounts = 0</span><br><span class="line">    dp[0][startRow][startColumn] = 1</span><br><span class="line">    for move in range(maxMove):</span><br><span class="line">        for r in range(m):</span><br><span class="line">            for c in range(n):</span><br><span class="line">                if r == 0 or c == 0 or r == m-1 or c == n-1:</span><br><span class="line">                    t = dp[move][r][c]</span><br><span class="line">                    if t != 0:</span><br><span class="line">                        if r-1 &lt; 0:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if c-1 &lt; 0:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if r+1 == m:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                        if c+1 == n:</span><br><span class="line">                            outCounts += t</span><br><span class="line">                if move == maxMove-1:</span><br><span class="line">                    continue</span><br><span class="line">                for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:</span><br><span class="line">                    if i &gt;= 0 and i &lt; m and j &gt;= 0 and j &lt; n:</span><br><span class="line">                        dp[move+1][r][c] += dp[move][i][j]</span><br><span class="line"></span><br><span class="line">    return outCounts % (10**9+7)</span><br></pre></td></tr></table></figure>

<h3 id="方法二：-卷积"><a href="#方法二：-卷积" class="headerlink" title="方法二： 卷积"></a>方法二： 卷积</h3><p>大佬都在评论区。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">m, n, maxMove, startRow, startColumn</span>):</span></span><br><span class="line">    <span class="keyword">if</span> maxMove &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    a = numpy.zeros((m, n), )</span><br><span class="line">    a[startRow, startColumn] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    b = numpy.zeros((<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">int</span>)</span><br><span class="line">    b[<span class="number">0</span>][<span class="number">1</span>] = b[<span class="number">1</span>][<span class="number">0</span>] = b[-<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>][-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(a)</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(maxMove):</span><br><span class="line">        ans += (a[:, <span class="number">0</span>].<span class="built_in">sum</span>() + a[:, -<span class="number">1</span>].<span class="built_in">sum</span>() +</span><br><span class="line">                a[<span class="number">0</span>, :].<span class="built_in">sum</span>() + a[-<span class="number">1</span>, :].<span class="built_in">sum</span>()) % <span class="number">1_000_000_007</span></span><br><span class="line">        a = scipy.signal.convolve2d(a, b, <span class="string">&#x27;same&#x27;</span>) % <span class="number">1_000_000_007</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(ans) % <span class="number">1_000_000_007</span></span><br></pre></td></tr></table></figure>

<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/fXAdy9"><img src="https://z3.ax1x.com/2021/08/20/fXAdy9.jpg" alt="t提交记录1.jpg"></a><br><a href="https://imgtu.com/i/fXAaQJ"><img src="https://z3.ax1x.com/2021/08/20/fXAaQJ.jpg" alt="提交记录2.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>动态规划</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_789.逃脱阻碍者</title>
    <url>/2021/08/22/Leetcode-789-%E9%80%83%E8%84%B1%E9%98%BB%E7%A2%8D%E8%80%85/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>789. 逃脱阻碍者<br>难度：中等</p>
<p>你在进行一个简化版的吃豆人游戏。你从 <code>[0, 0]</code> 点开始出发，你的目的地是&nbsp;<code>target = [x<sub>target</sub>, y<sub>target</sub>]</code> 。地图上有一些阻碍者，以数组 <code>ghosts</code> 给出，第 <code>i</code> 个阻碍者从&nbsp;<code>ghosts[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;出发。所有输入均为 <strong>整数坐标</strong> 。</p>

<p>每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 <strong>1 个单位</strong> 的新位置。当然，也可以选择 <strong>不动</strong> 。所有动作 <strong>同时</strong> 发生。</p>

<p>如果你可以在任何阻碍者抓住你 <strong>之前</strong> 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者同时到达了一个位置（包括目的地）都不算是逃脱成功。</p>

<p>只有在你有可能成功逃脱时，输出 <code>true</code> ；否则，输出 <code>false</code> 。</p>
&nbsp;

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>ghosts = [[1,0],[0,3]], target = [0,1]
<strong>输出：</strong>true
<strong>解释：</strong>你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。 
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>ghosts = [[1,0]], target = [2,0]
<strong>输出：</strong>false
<strong>解释：</strong>你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。 
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>ghosts = [[2,0]], target = [1,0]
<strong>输出：</strong>false
<strong>解释：</strong>阻碍者可以和你同时达到目的地。 
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>ghosts = [[5,0],[-10,-2],[0,-5],[-2,-2],[-7,1]], target = [7,7]
<strong>输出：</strong>false
</pre>

<p><strong>示例 5：</strong></p>

<pre><strong>输入：</strong>ghosts = [[-1,0],[0,1],[-1,0],[0,1],[-1,0]], target = [0,0]
<strong>输出：</strong>true
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= ghosts.length &lt;= 100</code></li>
    <li><code>ghosts[i].length == 2</code></li>
    <li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
    <li>同一位置可能有 <strong>多个阻碍者</strong> 。</li>
    <li><code>target.length == 2</code></li>
    <li><code>-10<sup>4</sup> &lt;= x<sub>target</sub>, y<sub>target</sub> &lt;= 10<sup>4</sup></code></li>
</ul>


<h3 id="方法：-曼哈顿距离"><a href="#方法：-曼哈顿距离" class="headerlink" title="方法： 曼哈顿距离"></a>方法： 曼哈顿距离</h3><p>刚过十二点，看完题目是懵的，这是要干嘛？没有思路，去看题解，曼哈顿距离又是什么鬼？于是去B站上找一下曼哈顿距离的讲解，知道了就是两个点之间的横坐标距离与纵坐标距离的和。那这和解题有什么关系呢？上床在睡前想了一下，发现其实并不难。<br>题目中的情况虽然看起来很多很复杂，但其实要解决的就是”我“能不能比幽灵更快地到达目的地。因为中途被拦截地情况，也能变为让拦截者到了目的地之后等”我“，结果是一样的。因此，就是要考虑”我“的起点到目的地的曼哈顿距离是不是比所有幽灵到目的地的曼哈顿距离小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">escapeGhosts</span>(<span class="params">ghosts, target</span>):</span></span><br><span class="line">    target_x, target_y = target</span><br><span class="line">    L = <span class="built_in">abs</span>(target_x)+<span class="built_in">abs</span>(target_y)</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> ghosts:</span><br><span class="line">        l = <span class="built_in">abs</span>(x-target_x)+<span class="built_in">abs</span>(y-target_y)</span><br><span class="line">        <span class="keyword">if</span> l &lt;= L:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>还有一行的版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">escapeGhosts</span>(<span class="params">self, ghosts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>([<span class="built_in">abs</span>(target[<span class="number">0</span>])+<span class="built_in">abs</span>(target[<span class="number">1</span>]) &lt; <span class="built_in">abs</span>(ghost[<span class="number">0</span>]-target[<span class="number">0</span>])+<span class="built_in">abs</span>(ghost[<span class="number">1</span>]-target[<span class="number">1</span>]) <span class="keyword">for</span> ghost <span class="keyword">in</span> ghosts])</span><br><span class="line"></span><br><span class="line">作者：luanhz</span><br><span class="line">链接：https://leetcode-cn.com/problems/escape-the-ghosts/solution/wei-jin-zhe-sheng-pythonyi-xing-dai-ma-by-luanz/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。<br>元素除了是 0、空、None、False 外都算 True。</p>
</blockquote>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hSCRQe"><img src="https://z3.ax1x.com/2021/08/22/hSCRQe.jpg" alt="逃脱阻碍者提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>曼哈顿距离</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode题解</title>
    <url>/2021/08/17/Leetcode%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>因为既想在Github上传题解思路和代码，又想在博客上传，但保证两边同步好麻烦，所以这里列一个列表，链接到Github上。</p>
<h3 id="301-400"><a href="#301-400" class="headerlink" title="301-400"></a>301-400</h3><ul>
<li><a href="https://github.com/shengrihui/Leetcode/blob/c396f399bcca39c40923411eabf0306c7d89739f/3/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.md">345. 反转字符串中的元音字母</a><h3 id="501-600"><a href="#501-600" class="headerlink" title="501~600"></a>501~600</h3></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/5acbc6232b0a90c9cf3beaaa4972ba3e9174d7ab/5/526.%20%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/526.%20%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97.md">526.优美的排列</a></li>
<li>[541. 反转字符串 ](<a href="https://github.com/shengrihui/Leetcode/blob/c5b27e27baac035e0fddb3e64867fab88630da82/5/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II.md">https://github.com/shengrihui/Leetcode/blob/c5b27e27baac035e0fddb3e64867fab88630da82/5/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II/541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II.md</a></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/96ca3695c85441f9cc189b123944249f5bb81bbc/5/551.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20I/551.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20I_%E9%A2%98%E8%A7%A3.md">551. 学生出勤记录 I_题解</a></li>
<li><a href="https://github.com/shengrihui/Leetcode/blob/c396f399bcca39c40923411eabf0306c7d89739f/5/552.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20II/552.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20II.md">552. 学生出勤记录 II</a></li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2021/08/05/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 支持两种形式的标题, [Setext] [1] 和 [atx] [2].<br>Setext 样式的标题使用的等号来表示一级标题, 使用连字符表示二级标题. 例如:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">&gt;This is an H1</span></span><br><span class="line"><span class="section">=============</span></span><br><span class="line">This is an H2</span><br><span class="line">&gt;-------------</span><br></pre></td></tr></table></figure>

<p>任意长度的 = 或 - 都是可以的.<br>Atx 样式的标题每行开头使用 1-6 井号, 对应 1-6 级标题. 例如:</p>
</blockquote>
<blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure>
<p>可选地, 你可以 “关闭” atx 样式的标题. 这纯粹是美化需要 – 如果你认为这样美观一些就用吧. 关&gt;闭标签的井号数量甚至不需要和起始位置的匹配. (起始的井号数量决定了标题的级别.) :</p>
<h1 id="This-is-an-H1"><a href="#This-is-an-H1" class="headerlink" title="This is an H1"></a>This is an H1</h1><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2"></a>This is an H2</h2><h3 id="This-is-an-H3"><a href="#This-is-an-H3" class="headerlink" title="This is an H3"></a>This is an H3</h3></blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题 ##</span></span><br><span class="line"><span class="section">这也是一级标题</span></span><br><span class="line"><span class="section">=========</span></span><br><span class="line"><span class="section">这是二级标题</span></span><br><span class="line"><span class="section">-------</span></span><br></pre></td></tr></table></figure>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><blockquote>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h1 id="这也是一级标题"><a href="#这也是一级标题" class="headerlink" title="这也是一级标题"></a>这也是一级标题</h1><h2 id="这是二级标题-1"><a href="#这是二级标题-1" class="headerlink" title="这是二级标题"></a>这是二级标题</h2></blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 使用 email 样式的 &gt; 字符作为块引用. 如果你熟悉 email 消息中的引用段落, 那么你同样可以在 Markdown 中创建块引用. 最好对引用文本采取强制换行并在每一行行首放一个 &gt; :</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span></span><br><span class="line"><span class="quote">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span></span><br><span class="line"><span class="quote">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span></span><br><span class="line"><span class="quote">&gt; id sem consectetuer libero luctus adipiscing.</span></span><br></pre></td></tr></table></figure>
<p>Markdown 中可以简便地只在每一个需要强制换行的段落的首行前面加上一个 &gt; :</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span></span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span></span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>块引用可以嵌套 (例如, 块引用中包含块引用) , 只需添加额外层级的 &gt; 即可:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is the first level of quoting.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; &gt; This is nested blockquote.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Back to the first level.</span></span><br></pre></td></tr></table></figure>
<p>块引用可以包含 Markdown 元素, 包括标题, 列表和代码块:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; ## This is a header.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 1.   This is the first list item.</span></span><br><span class="line"><span class="quote">&gt; 2.   This is the second list item.</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; Here&#x27;s some example code:</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;     return shell<span class="emphasis">_exec(&quot;echo $input | $markdown_</span>script&quot;);</span></span><br><span class="line">&gt;、</span><br></pre></td></tr></table></figure>
<p>任何合适的文本编辑器都应该可以很方便的创建 email 样式的块引用. 例如, 用 BBEdit 就可以选取文本然后从 ‘Text’ 菜单中选择 ‘Increase Quote Level’.</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;这是一级引用</span><br><span class="line">&gt;&gt;这是二级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;这是好多级引用</span><br></pre></td></tr></table></figure>
<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><blockquote>
<p>这是一级引用</p>
<blockquote>
<p>这是二级引用</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是好多级引用</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="文档-2"><a href="#文档-2" class="headerlink" title="文档"></a>文档</h3><blockquote>
<p>Markdown 支持有序列表和无序列表.</p>
<p>无序列表使用星号, 加号, 和连字符 – 这些符号是可互换的 – 最为列表标记:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Red</span><br><span class="line"><span class="bullet">*</span>   Green</span><br><span class="line"><span class="bullet">*</span>   Blue</span><br></pre></td></tr></table></figure>
<p>等价于:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span>   Red</span><br><span class="line"><span class="bullet">+</span>   Green</span><br><span class="line"><span class="bullet">+</span>   Blue</span><br></pre></td></tr></table></figure>
<p>以及:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span>   Red</span><br><span class="line"><span class="bullet">-</span>   Green</span><br><span class="line"><span class="bullet">-</span>   Blue</span><br></pre></td></tr></table></figure>
<p>有序列表使用数字加句号:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Bird</span><br><span class="line"><span class="bullet">2.</span>  McHale</span><br><span class="line"><span class="bullet">3.</span>  Parish</span><br></pre></td></tr></table></figure>
<p>需要注意的是这里的数字序号对于最终生成 HTML 是没有影响的. 这里 Markdown 输出的 HTML 列表是:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>McHale<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Parish<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即使你把列表写成这样:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Bird</span><br><span class="line"><span class="bullet">1.</span>  McHale</span><br><span class="line"><span class="bullet">1.</span>  Parish</span><br></pre></td></tr></table></figure>
<p>甚至这样:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">3.</span> Bird</span><br><span class="line"><span class="bullet">1.</span> McHale</span><br><span class="line"><span class="bullet">8.</span> Parish</span><br></pre></td></tr></table></figure>
<p>你都讲得到相同的 HTML 输出. 重点是, 如果你希望你的 Markdown 源码中的列表序号匹配输出的 HTML 列表序号, 你应该使用正常的序号 . 当然, 如果你想简单点, 也可不必这么做.</p>
<p>即使你使用错误的列表序号, 最终生成的列表仍然会以序号 1 开始. 在未来的版本里, Markdown 可能支持以任意数字作为列表起始序号.</p>
<p>List 标记通常从左边开始, 可以用三个及以上的空格来缩进. List 标记后面应该跟一个以上的空格或者一个水平制表符.</p>
<p>为了使列表更美观, 可以用悬挂缩进来格式化列表项:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line"><span class="code">    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span></span><br><span class="line"><span class="code">    viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"><span class="code">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span></span><br><span class="line"><span class="code">    Suspendisse id sem consectetuer libero luctus adipiscing.</span></span><br><span class="line"><span class="code">    但是这不是必须的:</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span>   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"><span class="bullet">*</span>   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>如果列表项中包含空行, Markdown 会在 HTML 输出中用 </p><p> 来包裹他们. 例如, 下面的输入:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Bird</span><br><span class="line"><span class="bullet">*</span>   Magic</span><br></pre></td></tr></table></figure>
<p>会输出:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Magic<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   Bird</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   Magic</span><br></pre></td></tr></table></figure>
<p>会输出:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Bird<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Magic<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>列表项可能包含多个段落. 列表项中的每个段落都必须用 4 个空格或一个水平制表符来缩进:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line"><span class="code">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span></span><br><span class="line"><span class="code">    mi posuere lectus.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span></span><br><span class="line"><span class="code">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span></span><br><span class="line"><span class="code">    sit amet velit.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span>  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure>
<p>同上, 悬挂缩进只是为了更美观, 而非强制要求:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line"><span class="code">    This is the second paragraph in the list item. You&#x27;re</span></span><br><span class="line"><span class="code">only required to indent the first line. Lorem ipsum dolor</span></span><br><span class="line"><span class="code">sit amet, consectetuer adipiscing elit.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span>   Another item in the same list.</span><br></pre></td></tr></table></figure>
<p>如果列表项中包含块注释 , 块注释标记 &gt; 需要缩进:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span>   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line"><span class="code">    &gt; This is a blockquote</span></span><br><span class="line"><span class="code">    &gt; inside a list item.</span></span><br></pre></td></tr></table></figure>
<p>如果列表项中有代码块, 代码块需要 双倍 缩进– 8 个空格或者两个水平制表符:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> A list item with a code block:</span><br><span class="line"></span><br><span class="line"><span class="code">      &lt;code goes here&gt;</span></span><br></pre></td></tr></table></figure>

<p>有时候无意中出发有序列表, 如下面这样的代码:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1986.</span> What a great season.</span><br></pre></td></tr></table></figure>
<p>即使, 如果一行开头满足 number-period-space 模式. 可以通过转义点号来避免这种情况:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1986\. What a great season.</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>略</p>
<h2 id="代码块和代码"><a href="#代码块和代码" class="headerlink" title="代码块和代码"></a>代码块和代码</h2><h3 id="文档-3"><a href="#文档-3" class="headerlink" title="文档"></a>文档</h3><ul>
<li> 代码块<blockquote>
<p>预格式化的代码块用于输出编程语言和标记语言. 不同于普通段落, 代码块中的行会被原样呈现. Markdown 会用 <pre> 和 <code> 标签包围代码块.</code></pre></p>
<p>要在 Markdown 中插入代码块, 只需要将每一行都缩进 4 个空格或者 1 个水平制表符. 例如, 下面的输入:</p>
<pre><code>This is a normal paragraph:

    This is a code block.
</code></pre>
<p>Markdown 会生成:</p>
<pre><code>&lt;p&gt;This is a normal paragraph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;
</code></pre>
<p>只有一级缩进 – 4 个空格或者 1 个水平制表符 – 会从代码块中的每一行中移除. 例如:</p>
<pre><code>Here is an example of AppleScript:
                                                        
tell application &quot;Foo&quot;
    beep
end tell
</code></pre>
<p>会生成:</p>
<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre>
</blockquote>
</li>
<li>  代码<blockquote>
<p>要输出一个代码片段, 需要使用重音符号 (`). 不同于预格式的代码块, 代码片段只是在普通段落中标识出代码. 例如:</p>
<pre><code> Use the `printf()` function.
</code></pre>
<p>会生成:</p>
<pre><code> &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre>
<p>要在代码片段中包含字面量的重音符号, 可以使用多个重音符号作为起始和结束标记:</p>
<pre><code> ``There is a literal backtick (`) here.``
</code></pre>
<p>会生成:</p>
<pre><code> &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre>
<p>包含代码片段的重音符号可以包含空格 – 起始标记后一个, 结束标记前一个. 这使你可以在代码片段开始和结束位置使用重音符号的字面量:</p>
<pre><code> A single backtick in a code span: `` ` ``
                   
 A backtick-delimited string in a code span: `` `foo` ``
</code></pre>
<p>会生成:</p>
<pre><code> &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;
                   
 &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre>
<p>在代码片段中, 英镑符号和尖括号会被转换成相应的字符实体, 这使得包含 HTML 标签很容易. Markdown 会将下面的代码:</p>
<pre><code> Please don&#39;t use any `&lt;blink&gt;` tags.
</code></pre>
<p> 转成:</p>
<pre><code> &lt;p&gt;Please don&#39;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre>
<p>这样写:</p>
<pre><code> `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre>
<p>会生成:</p>
<pre><code> &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
 equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="文档总结和补充"><a href="#文档总结和补充" class="headerlink" title="文档总结和补充"></a>文档总结和补充</h3><ol>
<li>   选中写好了的代码，然后tab缩进就好了。</li>
<li>   还有一种是通过一对  `` (英文状态下tab键上面那个) 或者 ~~~  (英文状态下shift+tab上面那个) 将代码包起来。三个反撇号和三个波浪号各一行。再第一个```或~~~后可以加上代码的语言，这样可以有更好的显示效果。</li>
</ol>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5>  要加粗的文字左右分别用两个*号包起来</li>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5>  要倾斜的文字左右分别用一个*号包起来</li>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5> 要倾斜和加粗的文字左右分别用三个*号包起来</li>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5>  要加删除线的文字左右分别用两个~~号包起来<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4>  <strong>这是加粗的文字</strong><br>  <em>这是倾斜的文字</em><br>  <em><strong>这是倾斜加粗的文字</strong></em><br>  <del>这是添加删除线</del><h4 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h4></li>
</ul>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><em><strong>这是倾斜加粗的文字</strong></em><br><del>这是添加删除线</del></p>
<h3 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.  分割线"></a>4.  分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><pre><code>---
----
***
****
</code></pre>
<h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><hr>
<hr>
<hr>
<hr>
<h3 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h3><h4 id="语法-amp-示例"><a href="#语法-amp-示例" class="headerlink" title="语法&amp;示例"></a>语法&amp;示例</h4><pre><code>本地：
  ![狗]（markdown语法/dog.jpg &quot;狗&quot;）
</code></pre>
<h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><img src="/2021/08/05/markdown%E8%AF%AD%E6%B3%95/dog.jpg" class title="狗">



<img src="/2021/08/05/markdown%E8%AF%AD%E6%B3%95/dog.jpg" width="256" height="256">

 <img src="/2021/08/05/markdown%E8%AF%AD%E6%B3%95/dog.jpg" class title="狗">{:width="30px" height="10px"}]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>next主题配置</title>
    <url>/2021/08/20/next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="04-正确姿势打开标签页和分类页"><a href="#04-正确姿势打开标签页和分类页" class="headerlink" title="04 正确姿势打开标签页和分类页"></a>04 正确姿势打开标签页和分类页</h4><ol>
<li>命令<code>hexo n page tags</code>,source文件夹中多出一个包含index.html的tags文件夹。这时候博客中的“标签就能打开了。</li>
<li>修改index.html文件。<code>title</code>改为<code>标签</code>，增加一行<code>type: tags</code>（这句不写标签页不会有标签）。</li>
<li>命令：<code>hexo n page categories</code>创建分类页。</li>
<li>修改categories里的index.html ，与之前类似。</li>
</ol>
<h4 id="05-主题样式的更改"><a href="#05-主题样式的更改" class="headerlink" title="05 主题样式的更改"></a>05 主题样式的更改</h4><p>在样式配置文件中修改<code>Schemes</code>项。</p>
<h4 id="04-设置主题头像"><a href="#04-设置主题头像" class="headerlink" title="04 设置主题头像"></a>04 设置主题头像</h4><p>主题配置文件中<code>Avatar</code>项</p>
<h4 id="07-更改作者和标题以及链接"><a href="#07-更改作者和标题以及链接" class="headerlink" title="07 更改作者和标题以及链接"></a>07 更改作者和标题以及链接</h4><h4 id="08-启用侧边栏社交链接"><a href="#08-启用侧边栏社交链接" class="headerlink" title="08 启用侧边栏社交链接"></a>08 启用侧边栏社交链接</h4><ul>
<li>主题配置文件的<code>Social</code>项。</li>
</ul>
<h4 id="09-启用友情链接"><a href="#09-启用友情链接" class="headerlink" title="09 启用友情链接"></a>09 启用友情链接</h4><p>主题配置文件中<code>links_settings</code>项。</p>
<h4 id="10-新建一篇文章"><a href="#10-新建一篇文章" class="headerlink" title="10 新建一篇文章"></a>10 新建一篇文章</h4><ul>
<li><code>hexo n 文章名</code> 新建一篇文章</li>
<li>在文章里添加标签和分类：<br>  tags:<pre><code> - xx
 - xx
    categories:
    xx
</code></pre>
</li>
</ul>
<h4 id="11-Markdown的使用"><a href="#11-Markdown的使用" class="headerlink" title="11 Markdown的使用"></a>11 Markdown的使用</h4><h4 id="12-开启文章打赏功能"><a href="#12-开启文章打赏功能" class="headerlink" title="12 开启文章打赏功能"></a>12 开启文章打赏功能</h4><p>主题配置文件中<code>reward</code>项。</p>
<h4 id="13-开启订阅公众号"><a href="#13-开启订阅公众号" class="headerlink" title="13 开启订阅公众号"></a>13 开启订阅公众号</h4><p>主题配置文件中<code>wechat Subscriber</code>项。</p>
<h4 id="14-设置头像是圆形可旋转"><a href="#14-设置头像是圆形可旋转" class="headerlink" title="14 设置头像是圆形可旋转"></a>14 设置头像是圆形可旋转</h4><ul>
<li>打开文件<code>..\themes\hexo-theme-next\source\css\_common\outline\sidebar\sidebar-author.sty</code>，对其中的参数进行修改。</li>
<li>在主题配置文件中修改： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># If true, the avatar will be dispalyed in circle.</span><br><span class="line">rounded: true</span><br><span class="line"># If true, the avatar will be rotated with the cursor.</span><br><span class="line">rotated: true</span><br></pre></td></tr></table></figure>
第一个是让头像在圆中显示，第二个是鼠标移上去后旋转。</li>
</ul>
<h4 id="15-首页设置文章阅读全文"><a href="#15-首页设置文章阅读全文" class="headerlink" title="15 首页设置文章阅读全文"></a>15 首页设置文章阅读全文</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excerpt:</span><br><span class="line">  depth: 3  #按层来算，也就是按代码块来算</span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: true</span><br></pre></td></tr></table></figure>


<h4 id="背景黑色"><a href="#背景黑色" class="headerlink" title="背景黑色"></a>背景黑色</h4><h4 id="fork-Github"><a href="#fork-Github" class="headerlink" title="fork Github"></a>fork Github</h4><p>打开<code>..\themes\hexo-theme-next\layout</code>中的文件<code>_layout.swig</code>。<br>在<a href="https://tholman.com/github-corners/">https://tholman.com/github-corners/</a> 中选一个样式，将代码复制到文件中的<code>&lt;/header&gt;</code>前，并修改称自己的GitHub链接。</p>
<h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><p>按官方文档的local search来。<a href="http://theme-next.iissnan.com/third-party-services.html">http://theme-next.iissnan.com/third-party-services.html</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_1646. 获取生成数组中的最大值</title>
    <url>/2021/08/23/Leetcode-1646-%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>1646. 获取生成数组中的最大值<br>难度：简单</p>
<p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>

<ul>
    <li><code>nums[0] = 0</code></li>
    <li><code>nums[1] = 1</code></li>
    <li>当 <code>2 &lt;= 2 * i &lt;= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>
    <li>当 <code>2 &lt;= 2 * i + 1 &lt;= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>
</ul>

<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>3
<strong>解释：</strong>根据规则：
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
因此，nums = [0,1,1,2,1,3,2,3]，最大值 3
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>1
<strong>解释：</strong>根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>2
<strong>解释：</strong>根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<div class="notranslate"><p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>

<ul>
    <li><code>nums[0] = 0</code></li>
    <li><code>nums[1] = 1</code></li>
    <li>当 <code>2 &lt;= 2 * i &lt;= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>
    <li>当 <code>2 &lt;= 2 * i + 1 &lt;= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>
</ul>

<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>3
<strong>解释：</strong>根据规则：
  nums[0] = 0
  nums[1] = 1
  nums[(1 * 2) = 2] = nums[1] = 1
  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
  nums[(2 * 2) = 4] = nums[2] = 1
  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
  nums[(3 * 2) = 6] = nums[3] = 2
  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
因此，nums = [0,1,1,2,1,3,2,3]，最大值 3
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>1
<strong>解释：</strong>根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>2
<strong>解释：</strong>根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= n &lt;= 100</code></li>
</ul>


<h3 id="方法：-模拟"><a href="#方法：-模拟" class="headerlink" title="方法： 模拟"></a>方法： 模拟</h3><p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMaximumGenerated</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    nums = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    nums[<span class="number">0</span>], nums[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i*<span class="number">2</span>+<span class="number">1</span> &lt;= n:</span><br><span class="line">        nums[i*<span class="number">2</span>] = nums[i]</span><br><span class="line">        nums[i*<span class="number">2</span>+<span class="number">1</span>] = nums[i]+nums[i+<span class="number">1</span>]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br></pre></td></tr></table></figure>
<p>官方处理奇偶两种情况的方法挺好的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaximumGenerated</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            nums[i] = nums[i // <span class="number">2</span>] + i % <span class="number">2</span> * nums[i // <span class="number">2</span> + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者：LeetCode-Solution</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/get-maximum-in-generated-array/solution/huo-qu-sheng-cheng-shu-zu-zhong-de-zui-d-0z2l/</span></span><br><span class="line"><span class="comment"># 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment"># 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/h95spt"><img src="https://z3.ax1x.com/2021/08/23/h95spt.jpg" alt="获取生成数组中的最大值提交记录.jpg"></a></p>
</div>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_233. 数字 1 的个数</title>
    <url>/2021/08/23/Leetcode-233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode_787. K 站中转内最便宜的航班</title>
    <url>/2021/08/27/Leetcode-787-K-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>787. K 站中转内最便宜的航班<br>难度：中等</p>
<p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组&nbsp;<code>flights</code> ，其中&nbsp;<code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> ，表示该航班都从城市 <code>from<sub>i</sub></code> 开始，以价格 <code>price<sub>i</sub></code> 抵达 <code>to<sub>i</sub></code>。</p>

<p>现在给定所有的城市和航班，以及出发城市 <code>src</code> 和目的地 <code>dst</code>，你的任务是找到出一条最多经过 <code>k</code>&nbsp;站中转的路线，使得从 <code>src</code> 到 <code>dst</code> 的 <strong>价格最便宜</strong> ，并返回该价格。 如果不存在这样的路线，则输出 <code>-1</code>。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入:</strong> 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
<strong>输出:</strong> 200
<strong>解释:</strong> 
城市航班图如下
<img style="height: 180px; width: 246px;" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt>

从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入:</strong> 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
<strong>输出:</strong> 500
<strong>解释:</strong> 
城市航班图如下
<img style="height: 180px; width: 246px;" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt>

从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= n &lt;= 100</code></li>
    <li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>
    <li><code>flights[i].length == 3</code></li>
    <li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub> &lt; n</code></li>
    <li><code>from<sub>i</sub> != to<sub>i</sub></code></li>
    <li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></code></li>
    <li>航班没有重复，且不存在自环</li>
    <li><code>0 &lt;= src, dst, k &lt; n</code></li>
    <li><code>src != dst</code></li>
</ul>


<h3 id="方法一-枚举"><a href="#方法一-枚举" class="headerlink" title="方法一: 枚举"></a>方法一: 枚举</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol>
<li>先创建一个字典，用于存从某一个地方出发，可以到哪些目的地以及花费是多少；</li>
<li>建立两个列表，分别存这一次可以从哪些地方出发，以及到这个地方已经用了的花费；</li>
<li>再建立两个临时列表，分别存在遍历出发地点的列时的目的地，以及到达目的地的的花费；</li>
<li>若遇到了目的地是<code>dst</code>，就将花费记录到另一个<code>ret</code>列表当中；</li>
<li>遍历完一遍出发列表后，<code>k</code>自减，将<code>3</code>中的列表分别赋给<code>2</code>中的列表；</li>
<li>直到<code>k</code>变为负数，输出<code>ret</code>中的最小值，如果没有，输出<code>-1</code>。<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span>(<span class="params">n, flights, src, dst, k</span>):</span></span><br><span class="line">    dst_price = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s, d, p <span class="keyword">in</span> flights:</span><br><span class="line">        dst_price[s].append([d, p])</span><br><span class="line">        <span class="comment">#dst_price[d].append([s, p])</span></span><br><span class="line">    <span class="comment"># print(dst_price)</span></span><br><span class="line">    next_place = [src]</span><br><span class="line">    next_price = [<span class="number">0</span>]</span><br><span class="line">    temp_place = []</span><br><span class="line">    temp_price = []</span><br><span class="line">    kk = k</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">while</span> k &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> f, p0 <span class="keyword">in</span> <span class="built_in">zip</span>(next_place, next_price):</span><br><span class="line">            <span class="keyword">for</span> d, p <span class="keyword">in</span> dst_price[f]:</span><br><span class="line">                temp_place.append(d)</span><br><span class="line">                temp_price.append(p0+p)</span><br><span class="line">                <span class="comment"># print(f,d,temp_place)</span></span><br><span class="line">                <span class="comment"># print(temp_price)</span></span><br><span class="line">                <span class="keyword">if</span> d == dst:</span><br><span class="line">                    ret.append(p0+p)</span><br><span class="line">        next_place = temp_place</span><br><span class="line">        next_price = temp_price</span><br><span class="line">        <span class="comment"># print(next_place)</span></span><br><span class="line">        <span class="comment"># print(next_price,&quot;***&quot;)</span></span><br><span class="line">        temp_place = []</span><br><span class="line">        temp_price = []</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ret) <span class="keyword">if</span> ret != [] <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4>可能会出现两个地方来回的情况，造成超级大量的浪费计算。</li>
</ol>
<h3 id="方法二：-回溯"><a href="#方法二：-回溯" class="headerlink" title="方法二： 回溯"></a>方法二： 回溯</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span>(<span class="params">n, flights, src, dst, k</span>):</span></span><br><span class="line">    dst_price = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s, d, p <span class="keyword">in</span> flights:</span><br><span class="line">        dst_price[s].append([d, p])</span><br><span class="line"></span><br><span class="line">    place = [src]</span><br><span class="line">    price = [<span class="number">0</span>]</span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">k, place, price</span>):</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> d, p0 <span class="keyword">in</span> dst_price[place[-<span class="number">1</span>]]:</span><br><span class="line">            <span class="keyword">if</span> d == dst:</span><br><span class="line">                ret.append(price[-<span class="number">1</span>]+p0)</span><br><span class="line">            place.append(d)</span><br><span class="line">            price.append(price[-<span class="number">1</span>]+p0)</span><br><span class="line">            forward(k-<span class="number">1</span>, place, price)</span><br><span class="line">            place.pop()</span><br><span class="line">            price.pop()</span><br><span class="line">    forward(k, place, price)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ret) <span class="keyword">if</span> ret != [] <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="方法三：-动态规划"><a href="#方法三：-动态规划" class="headerlink" title="方法三： 动态规划"></a>方法三： 动态规划</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我刚开始的时候想，某次换成之后的最便宜的花费等于换成之前的那么多可能的站里的最便宜的花费加上这一段的花费，然而显然不是这样的，一度认为这一题不能用动态规划来做。而事实上这是错的，因为到某一站的最便宜花费应当等于到上一站的所有可能的站的最便宜花费分别加上这些上一站到这一站的花费之后所有花费当中最便宜的。还是用式子和代码来表示这些狗屁不通的话吧。</p>
<ol>
<li>状态:<code>dp[t][d]</code>表示第<code>t</code>次换乘时到<code>d</code>站的最小花费;</li>
<li>状态转移方程::<code>dp[t][d] = min(dp[t][d], dp[t-1][f]+cost)</code>,<code>cost</code>是<code>f</code>站到<code>d</code>站的花费,所以第<code>t</code>次换乘时到<code>d</code>站的最小花费等于所有能到<code>d</code>站的那些站到<code>d</code>站的最便宜花费加上那些站到<code>d</code>站的花费当中的最小值.</li>
<li>初始状态:<code>d[0][src]=0</code>.<br>其他注意的</li>
<li><code>k</code>次换乘,也就会有<code>k+2</code>个站,,注意相关循环的范围以及<code>dp</code>的设置;</li>
<li><code>float(&quot;inf&quot;)</code>表示无穷大.<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span>(<span class="params">n, flights, src, dst, k</span>):</span></span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">2</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][src] = <span class="number">0</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> f, d, cost <span class="keyword">in</span> flights:</span><br><span class="line">            dp[t][d] = <span class="built_in">min</span>(dp[t][d], dp[t-<span class="number">1</span>][f]+cost)</span><br><span class="line">            <span class="keyword">if</span> d == dst <span class="keyword">and</span> dp[t][d] != <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>):</span><br><span class="line">                ret.append(dp[t][d])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(ret) <span class="keyword">if</span> ret != [] <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span>(<span class="params">n, flights, src, dst, k</span>):</span></span><br><span class="line">    <span class="comment"># dst_price = defaultdict(list)</span></span><br><span class="line">    <span class="comment"># for s, d, p in flights:</span></span><br><span class="line">    <span class="comment">#     dst_price[s].append([d, p])</span></span><br><span class="line"></span><br><span class="line">    dp = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*n</span><br><span class="line">    ans = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># next_place = [src]</span></span><br><span class="line">    dp[src] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">2</span>):</span><br><span class="line">        g = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]*n</span><br><span class="line">        <span class="keyword">for</span> f,d,cost <span class="keyword">in</span> flights:</span><br><span class="line">            g[d]=<span class="built_in">min</span>(g[d],dp[f]+cost)</span><br><span class="line">        <span class="comment"># temp = []</span></span><br><span class="line">        <span class="comment"># for f in next_place:</span></span><br><span class="line">        <span class="comment">#     for d, p in dst_price[f]:</span></span><br><span class="line">        <span class="comment">#         g[d] = min(g[d], dp[f]+p)</span></span><br><span class="line">        <span class="comment">#         temp.append(d)</span></span><br><span class="line">            <span class="keyword">if</span> d == dst:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, g[d])</span><br><span class="line">        dp = g</span><br><span class="line">        <span class="comment"># next_place = temp</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ans == <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hAHnSS"><img src="https://z3.ax1x.com/2021/08/24/hAHnSS.jpg" alt="航班换乘提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_797. 所有可能的路径</title>
    <url>/2021/08/26/Leetcode-797-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>797. 所有可能的路径<br>难度：中等</p>
<p>给你一个有&nbsp;<code>n</code>&nbsp;个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code>&nbsp;到节点 <code>n-1</code>&nbsp;的路径并输出（<strong>不要求按特定顺序</strong>）</p>

<p>二维数组的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code> 号节点所能到达的下一些节点，空就是没有下一个结点了。</p>

<p>译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img style="height: 242px; width: 242px;" src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt></p>

<pre><strong>输入：</strong>graph = [[1,2],[3],[3],[]]
<strong>输出：</strong>[[0,1,3],[0,2,3]]
<strong>解释：</strong>有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3
</pre>

<p><strong>示例 2：</strong></p>

<p><img style="height: 301px; width: 423px;" src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" alt></p>

<pre><strong>输入：</strong>graph = [[4,3,1],[3,2,4],[3],[4],[]]
<strong>输出：</strong>[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>graph = [[1],[]]
<strong>输出：</strong>[[0,1]]
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>graph = [[1,2,3],[2],[3],[]]
<strong>输出：</strong>[[0,1,2,3],[0,2,3],[0,3]]
</pre>

<p><strong>示例 5：</strong></p>

<pre><strong>输入：</strong>graph = [[1,3],[2],[3],[]]
<strong>输出：</strong>[[0,1,2,3],[0,3]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>n == graph.length</code></li>
    <li><code>2 &lt;= n &lt;= 15</code></li>
    <li><code>0 &lt;= graph[i][j] &lt; n</code></li>
    <li><code>graph[i][j] != i</code>（即，不存在自环）</li>
    <li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li>
    <li>保证输入为 <strong>有向无环图（DAG）</strong></li>
</ul>


<h3 id="方法一：-回溯-深度优先搜索（DFS）"><a href="#方法一：-回溯-深度优先搜索（DFS）" class="headerlink" title="方法一：  回溯/深度优先搜索（DFS）"></a>方法一：  回溯/深度优先搜索（DFS）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(graph)</span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">temp, node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node == n-<span class="number">1</span>:</span><br><span class="line">                ret.append(temp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[node]:</span><br><span class="line">                temp.append(i)</span><br><span class="line">                backtrack(temp, i)</span><br><span class="line">                temp.pop()</span><br><span class="line">        backtrack([<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p>正常的回溯套路，需要注意的是：</p>
<ol>
<li>每个列表<code>apppend</code>的时候到底加的是什么东西；</li>
<li>开头的<code>0</code>的加上；</li>
<li><code>ret.append(temp[:])</code>用这种方式可以解决深浅拷贝的问题。</li>
</ol>
<h3 id="方法二：-宽度优先搜索（BFS）"><a href="#方法二：-宽度优先搜索（BFS）" class="headerlink" title="方法二： 宽度优先搜索（BFS）"></a>方法二： 宽度优先搜索（BFS）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line">        <span class="comment"># 创建一个先进先出的队列</span></span><br><span class="line">        q = Queue()</span><br><span class="line">        n = <span class="built_in">len</span>(graph)-<span class="number">1</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="comment"># 向队列中加入元素</span></span><br><span class="line">        q.put([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            <span class="comment"># 取出队列中的元素（因为是先进先出，所以是第一个）</span></span><br><span class="line">            tmp = q.get()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[tmp[-<span class="number">1</span>]]:</span><br><span class="line">                <span class="keyword">if</span> i == n:</span><br><span class="line">                    ret.append(tmp+[i])</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                q.put(tmp+[i])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hKFuX8"><img src="https://z3.ax1x.com/2021/08/26/hKFuX8.md.jpg" alt="提交记录.md.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode中等</tag>
        <tag>回溯</tag>
        <tag>深度优先搜索（DFS）</tag>
        <tag>广度优先搜索（BFS）</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_881. 救生艇</title>
    <url>/2021/08/26/Leetcode-881-%E6%95%91%E7%94%9F%E8%89%87/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>881. 救生艇<br>难度：中等</p>
<p>第&nbsp;<code>i</code>&nbsp;个人的体重为&nbsp;<code>people[i]</code>，每艘船可以承载的最大重量为&nbsp;<code>limit</code>。</p>

<p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为&nbsp;<code>limit</code>。</p>

<p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>people = [1,2], limit = 3
<strong>输出：</strong>1
<strong>解释：</strong>1 艘船载 (1, 2)
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>people = [3,2,2,1], limit = 3
<strong>输出：</strong>3
<strong>解释：</strong>3 艘船分别载 (1, 2), (2) 和 (3)
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>people = [3,5,3,4], limit = 5
<strong>输出：</strong>4
<strong>解释：</strong>4 艘船分别载 (3), (3), (4), (5)</pre>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;=&nbsp;people.length &lt;= 50000</code></li>
    <li><code>1 &lt;= people[i] &lt;=&nbsp;limit &lt;= 30000</code></li>
</ul>


<h3 id="方法一：-贪心-排序-双指针"><a href="#方法一：-贪心-排序-双指针" class="headerlink" title="方法一： 贪心=排序+双指针"></a>方法一： 贪心=排序+双指针</h3><p>将<code>people</code>数组排序之后，用双指针的方法来做。要使船的数量尽可能少，那就让一个船上的人尽可能多，也就是让体重大的，尽可能和一个体重轻的坐一个船。两个指针<code>i</code>和<code>j</code>，一个从轻往重走，一个从重往轻走，如果可以一起坐船，两个指针一起动，<code>boats</code>计数自增；如果两个不能一起坐船，那就重的指针移动，计数自增；直到两个指针重合，这时候，计数还需要再自增一次。<br>贪心相当于思想，排序+双指针是具体的实现方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span>(<span class="params">people, limit</span>):</span></span><br><span class="line">    people.sort()</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(people)-<span class="number">1</span></span><br><span class="line">    boats = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> people[i]+people[j] &gt; limit:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            boats+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            boats+=<span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==j:</span><br><span class="line">            boats+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> boats</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span>(<span class="params">self, people: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        people.sort()</span><br><span class="line">        light, heavy = <span class="number">0</span>, <span class="built_in">len</span>(people) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> light &lt;= heavy:</span><br><span class="line">            <span class="keyword">if</span> people[light] + people[heavy] &gt; limit:</span><br><span class="line">                heavy -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                light += <span class="number">1</span></span><br><span class="line">                heavy -= <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/boats-to-save-people/solution/jiu-sheng-ting-by-leetcode-solution-0nsp/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="方法二：-贪心"><a href="#方法二：-贪心" class="headerlink" title="方法二： 贪心"></a>方法二： 贪心</h3><p>这其实使我首先想到的方法，但。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span>(<span class="params">people, limit</span>):</span></span><br><span class="line">    d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    i, j = limit+<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> people:</span><br><span class="line">        d[w] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; w:</span><br><span class="line">            i = w</span><br><span class="line">        <span class="keyword">if</span> j &lt; w:</span><br><span class="line">            j = w</span><br><span class="line">    boats = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> d[j]==<span class="number">0</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> d[i] == <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> i+j &gt; limit:</span><br><span class="line">            boats += d[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        m = <span class="built_in">min</span>(d[i], d[j])</span><br><span class="line">        boats += m</span><br><span class="line">        d[i] -= m</span><br><span class="line">        d[j] -= m</span><br><span class="line">        <span class="comment"># i += (1-d[i]/1)</span></span><br><span class="line">        <span class="comment"># # if d[i]==0:</span></span><br><span class="line">        <span class="comment"># #     i-=1</span></span><br><span class="line">        <span class="comment"># j -= (1-d[j]/1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i &lt;= limit/<span class="number">2</span>:</span><br><span class="line">        boats += (d[i]+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        boats += d[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boats</span><br></pre></td></tr></table></figure>
<p>说明：<br>这里的做法是先统计了每种体重的人数，然后再用双指针的方法根据人数来做。<br>每次进入循环的时候，都要先判断对应体重的人数是不是0，这是因为，如果是0而没有先做处理的话，会出现<code>if i+j &gt; limit:</code>依然被执行的情况。<br>以为这种方法会减少时间消耗，然而并没有。</p>
<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hKF2jK"><img src="https://z3.ax1x.com/2021/08/26/hKF2jK.jpg" alt="救生艇提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>Leetcode中等</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda</title>
    <url>/2021/08/29/cuda/</url>
    <content><![CDATA[<p>pip安装<br>pip3 install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio===0.9.0 -f <a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a></p>
<p>conda<br>NOTE: ‘conda-forge’ channel is required for cudatoolkit 11.1<br>conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch -c conda-forge</p>
<p><a href="https://pytorch.org/">https://pytorch.org/</a></p>
]]></content>
      <categories>
        <category>一些命令</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode_1221. 分割平衡字符串</title>
    <url>/2021/09/07/Leetcode-1221-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>1221. 分割平衡字符串<br>难度：简单</p>
<p>在一个 <strong>平衡字符串</strong> 中，<code>'L'</code> 和 <code>'R'</code> 字符的数量是相同的。</p>

<p>给你一个平衡字符串&nbsp;<code>s</code>，请你将它分割成尽可能多的平衡字符串。</p>

<p><strong>注意：</strong>分割得到的每个字符串都必须是平衡字符串。</p>

<p>返回可以通过分割得到的平衡字符串的 <strong>最大数量</strong> <strong>。</strong></p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>s = "RLRRLLRLRL"
<strong>输出：</strong>4
<strong>解释：</strong>s 可以分割为 "RL"、"RRLL"、"RL"、"RL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>s = "RLLLLRRRLR"
<strong>输出：</strong>3
<strong>解释：</strong>s 可以分割为 "RL"、"LLLRRR"、"LR" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>s = "LLLLRRRR"
<strong>输出：</strong>1
<strong>解释：</strong>s 只能保持原样 "LLLLRRRR".
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>s = "RLRRRLLRLL"
<strong>输出：</strong>2
<strong>解释：</strong>s 可以分割为 "RL"、"RRRLLRLL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= s.length &lt;= 1000</code></li>
    <li><code>s[i] = 'L' 或 'R'</code></li>
    <li><code>s</code> 是一个 <strong>平衡</strong> 字符串</li>
</ul>


<h3 id="方法一：-贪心"><a href="#方法一：-贪心" class="headerlink" title="方法一： 贪心"></a>方法一： 贪心</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedStringSplit</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span> ,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l == r:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedStringSplit</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, d = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                d += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https://leetcode-cn.com/problems/split-a-string-<span class="keyword">in</span>-balanced-strings/solution/fen-ge-ping-heng-zi-fu-chuan-by-leetcode-7y8u/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="提交记录"><a href="#提交记录" class="headerlink" title="提交记录"></a>提交记录</h3><p><a href="https://imgtu.com/i/hoq3tI"><img src="https://z3.ax1x.com/2021/09/07/hoq3tI.jpg" alt="平衡字符串提交记录.jpg"></a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode简单</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>1</title>
    <url>/2021/09/07/1/</url>
    <content><![CDATA[<p>11111111111</p>
]]></content>
  </entry>
</search>
